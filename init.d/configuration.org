#+TITLE: Emacs configuration
#+PROPERTY: header-args:emacs-lisp :lexical t

Inspired by [[https://github.com/hrs/dotfiles/tree/abc679db03ed7f7e5ec2cf1f893f56513ea4df4d][hrs]] and [[https://github.com/pierre-lecocq/emacs.d/tree/literal][pierre-lecocq]] org configs

* General
** Lexical binding
   Enable lexical binding in this config
   #+begin_src emacs-lisp
   ;; -*- lexical-binding: t -*-
   #+end_src
** Load setup
   #+begin_src emacs-lisp
     (require 'setup)
   #+end_src
** Customizations
   Set emacs to save the customizations in a separate file to avoid
   having them in the git repo.
   #+begin_src emacs-lisp
     (setup custom
       (:option custom-file (expand-file-name ".custom.el" user-emacs-directory))
       (when (file-exists-p custom-file)
         (load custom-file)))
   #+end_src
** Package management

   Setup repositories for package and auto download use-package if
   it's missing.
   #+begin_src emacs-lisp
     (require 'package)

     (setq package-archives
           '(("melpa-stable" . "https://stable.melpa.org/packages/")
             ("melpa"        . "https://melpa.org/packages/")
             ("gnu"          . "https://elpa.gnu.org/packages/")
             ("org"          . "https://orgmode.org/elpa/")))

     (package-initialize)

     (when (not package-archive-contents)
       (package-refresh-contents))

     (setq package-enable-at-startup nil)

     (unless (getenv "GUIX_PROFILE")
       ;; Pin melpa-stable for packages not under use-package control, i.e
       ;; dependencies and use-package itself.
       (setq package-pinned-packages
             '((use-package . "melpa")
               ;; Deps
               (async       . "melpa")
               (bind-key    . "melpa-stable")
               (dash        . "melpa")
               (delight     . "gnu")
               (epl         . "melpa-stable")
               (git-commit  . "melpa")
               (magit-popup . "melpa")
               (pkg-info    . "melpa-stable")
               (popup       . "melpa-stable")
               (s           . "melpa-stable")
               (with-editor . "melpa")))

       (unless (package-installed-p 'use-package)
         (package-install 'use-package))
       (unless (package-installed-p 'delight)
         (package-install 'delight)))
   #+end_src

   Let use-package handle all the packages I use
   #+begin_src emacs-lisp
     (eval-when-compile
       (require 'use-package))
     (require 'delight)        ;; if you use :delight
     (require 'bind-key)       ;; if you use any :bind variant
   #+end_src

   Install missing packages.
   #+begin_src emacs-lisp
     (setq use-package-always-ensure (not (getenv "GUIX_PROFILE")))
   #+end_src
** Custom plugins
*** Dotemacs
    Export a variable if I'm at work or not.
    #+begin_src emacs-lisp
      (setup dotemacs
        (:load-from (expand-file-name "plugins" user-emacs-directory))
        (:require dotemacs))
    #+end_src
** UI
*** Maximize work area
   Disable the menu, tool and scroll bar since they just take up
   space.
   #+begin_src emacs-lisp
     (menu-bar-mode 0)
     (tool-bar-mode 0)
     (when (window-system) (scroll-bar-mode 0))
   #+end_src
*** Font
    Set font and font size depending on if using HiDPI or not.
    #+begin_src emacs-lisp
      (dotemacs-font-setup)
    #+end_src

    Inherit font for frames when creating a new frame.
    #+begin_src emacs-lisp
    (setq frame-inherited-parameters '(font))
    #+end_src
*** Column number
   Show column number in the info bar
   #+begin_src emacs-lisp
     (column-number-mode 1)
   #+end_src
** Behaviour
   Changing the default emacs behavior to better suite me.
   #+begin_src emacs-lisp
     (setq-default
      electric-indent-mode nil        ;; Disable electric-indent-mode, C-j is used for that.
      load-prefer-newer t             ;; Avoid loading outdated byte code files.
      auto-hscroll-mode 'current-line ;; Activate single-line horizontal scrolling mode (emacs-26 and up).
      inhibit-splash-screen t         ;; Dismiss the startup screen.
      initial-scratch-message nil     ;; Empty scratch buffer.
      indent-tabs-mode nil            ;; Don't use tab for indenting.
      sentence-end-double-space nil   ;; Use sane defaults for sentences.
      display-time-24hr-format t
      scroll-step 1                   ;; smooth scrolling
      scroll-conservatively 10000
      tab-always-indent 'complete
      completion-ignore-case t        ;; Ignore case when completing.
      read-file-name-completion-ignore-case t ;; Ignore case when finding files.
      read-buffer-completion-ignore-case t ;; Ignore case when switching buffers.
      enable-recursive-minibuffers t  ;; Allow to use the minibuffer while using the minibuffer
      )
     (show-paren-mode 1)                ;; Highlight matching brackets.
     (minibuffer-depth-indicate-mode 1) ;; Keep track of which minibuffer

     (define-key minibuffer-local-completion-map (kbd "SPC") 'self-insert-command)
   #+end_src

   Don't popup a new frame but reuse one that is already open. If no
   other frame is open, open in the same frame.
   #+begin_src emacs-lisp
     (setq display-buffer--other-frame-action
           '((display-buffer-reuse-window display-buffer-use-some-frame)
             (reusable-frames . visible)
             (inhibit-same-window . t)
             (inhibit-switch-frame . t)))
   #+end_src
**** Trailing Whitespaces

     Show trailing whitespaces for all modes that inherits from
     prog-mode. Keep it off for buffers that are read only as you
     cannot do anything about it.
     #+begin_src emacs-lisp
       (setup prog
         (:hook (lambda () (setf show-trailing-whitespace (not buffer-read-only)))))
     #+end_src

     *NOTE* Had it on for every writable buffer and then just turned
     it off for modes that I found it useless. But it got old fast to
     try and hunt down all modes and their hook for turning it off. As
     there were more modes than I had excepted that I needed to turn
     this off for, e.g. =ivy= buffers, =comint= modes, =calendar= etc.

**** Read only

     Change the cursor when in a read only buffer.
     #+begin_src emacs-lisp
       (setup read-only
         (:hook (lambda () (setq-local cursor-type (if buffer-read-only 'hbar 'box)))))
     #+end_src

** Calender
   #+begin_src emacs-lisp
     (setq-default
      calendar-week-start-day 1       ;; Week starts on Monday.
      calendar-day-name-array
      ["söndag" "måndag" "tisdag" "onsdag" "torsdag" "fredag" "lördag"]
      calendar-day-header-array ["sö" "må" "ti" "on" "to" "fr" "lö"]
      calendar-month-name-array
      ["januari" "februari" "mars" "april" "maj" "juni"
       "juli" "augusti" "september" "oktober" "november" "december"]
      calendar-time-display-form '(24-hours ":" minutes (if time-zone " (") time-zone (if time-zone ")"))
      calendar-date-style 'european)
   #+end_src
** Backup/autosave
   One annoying thing with emacs is it that it leaves backup files all
   over the place.  Fixing that by dumping all backup/autosave files
   in to one directory.
   #+begin_src emacs-lisp
     (let ((backup-dir (expand-file-name "backup" user-emacs-directory))
           (autosave-dir (expand-file-name "autosave" user-emacs-directory)))
       (setq backup-directory-alist (list (cons ".*" backup-dir))
             auto-save-list-file-prefix autosave-dir
             auto-save-file-name-transforms `((".*" ,autosave-dir t))))
   #+end_src
** Theme
   Point emacs to where it can find the sunburst theme.
   #+begin_src emacs-lisp
     (add-to-list 'custom-theme-load-path
                  (dotemacs-build-path user-emacs-directory "themes" "plattfot-theme"))
     (load-theme `plattfot t)
   #+end_src
** Path
   #+begin_src emacs-lisp
     (add-to-list 'exec-path (expand-file-name "~/bin"))
   #+end_src
* Packages
** Code
*** Autocomplete
    Packages that helps speed up coding, i.e. auto complete, boiler
    plates etc
**** Corfu
     #+begin_src emacs-lisp
       (setup (:require corfu)
         (corfu-global-mode))
     #+end_src

     Recommended keybindings by [[https://github.com/minad/corfu#configuration][corfu]]. Setting
     =dabbrev-upcase-means-case-search= and =dabbrev-case-replace=
     directly instead of relying on =case-fold-search= and
     =case-replace= otherwise the suggestions for =dabbrev= looses
     their case, which makes it unusable when programming.

     #+begin_src emacs-lisp
       (setup dabbrev
         ;; Swap M-/ and C-M-/
         (:global "M-/" dabbrev-completion
                  "C-M-/" dabbrev-expand)
         (:option dabbrev-upcase-means-case-search t
                  dabbrev-case-replace nil))
     #+end_src
**** Yasnippet
     Enable yasnippet
     #+begin_src emacs-lisp
       (setup yasnippet
         (:option yas-indent-line nil)
         (yas-global-mode 1))
     #+end_src
**** eglot
     Client for Language Server Protocol (lsp) servers.

     Tried both ~lsp-mode~ and ~eglot~. And for my use case ~eglot~ is
     better. ~lsp-mode~ involved a lot more tweaking to get it working
     (e.g. make sure ~company-capf~ is first in ~company-backends~).
     Once I got it working the completion menu in company was a lot
     nosier than what I get from ~eglot~. Only issue I have with
     ~eglot~ is the face in the mode-line. My mode-line is monochrome
     and is grayed out when the frame is not in focus. Which ~eglot~
     does not respect and by default it stands out like a sore thumb
     (I have the same issue with ~flymake~ and ~compilation~). I have
     tweaked my theme so it is not so bad. Still annoying though.

     *NOTE:* clangd also accepts arguments from the environment
     variable ~CLANGD_FLAGS~. I'm using that combined with ~direnv~
     to specify where the ~compile_commands.json~ is located. As that
     can change from project to project.

     For example set that ~compile_commands.json~ is in the
     subdirectory ~build~ in the root of the project.

     #+begin_src sh :tangle no
       # .envrc
       export CLANGD_FLAGS="--compile-commands-dir=./build"
     #+end_src

     #+begin_src emacs-lisp
       (setup (:require eglot)
         ;; Only run eglot on local buffers, too slow on bad connections.
         (:with-mode c++-mode
           (:hook
            (lambda ()
              (when (and (buffer-file-name) (not (file-remote-p (buffer-file-name))))
                (eglot-ensure)))))
         (:option gc-cons-threshold 100000000
                  read-process-output-max (* 1024 1024)) ;; 1mb
         (add-to-list 'eglot-server-programs
                      '(c++-mode . ("clangd"
                                    "--background-index"
                                    "--header-insertion=iwyu"
                                    "--pch-storage=memory"
                                    "-j=6"))))
     #+end_src
*** Lint
    Packages that helps inspecting code, report errors etc.
**** Flymake

     Moved over to using ~flymake~ instead of ~flycheck~. Mainly
     because it is the only one that works with ~eglot~ so keeping it
     consitent between modes.

     #+begin_src emacs-lisp
       (setup flymake
         (:hook-into prog-mode))
     #+end_src

     Flymake lacks linting for shell scripts. Testing out shellcheck.
     #+begin_src emacs-lisp
       (setup flymake-shellcheck
         (:needs "shellcheck")
         (add-hook 'sh-mode-hook 'flymake-shellcheck-load))
     #+end_src
*** Bugtracker
**** debbugs
     #+begin_src emacs-lisp
       (setup debbugs)
     #+end_src
*** Docs
**** devdocs
     #+begin_src emacs-lisp
       (setup devdocs
         (:global "C-c d I" devdocs-install
                  "C-c d i" devdocs-lookup))
     #+end_src
** Programming languages
  Modes for highlighting different programing languages.
*** Haskell
    Settings for programming haskell in emacs
    #+begin_src emacs-lisp
      (setup haskell
        (:hook turn-on-haskell-doc-mode
               turn-on-haskell-indent))
    #+end_src
*** Lisp
**** Smartparens

     Having issues with turning off auto balancing, i.e
     (|) - insert () -> (()|
     #+begin_src emacs-lisp
       (setup smartparens
         (:with-mode
             (;; c-mode-hook
              ;; c++-mode-hook
              lisp-mode
              scheme-mode
              guile-mode
              emacs-lisp-mode
              python-mode
              lisp-interaction-mode)
           (:hook turn-on-smartparens-mode))
         (:bind
          "C-)" sp-forward-slurp-sexp
          "C-(" sp-backward-slurp-sexp
          "C-}" sp-forward-barf-sexp
          "C-{" sp-backward-barf-sexp
          "C-M-a" sp-beginning-of-sexp
          "C-M-e" sp-end-of-sexp
          "C-M-t" sp-transpose-hybrid-sexp
          "C-M-s" sp-splice-sexp-killing-around
          "M-s" sp-split-sexp
          "M-[" sp-backward-unwrap-sexp
          "M-]" sp-unwrap-sexp
          "M-}" sp-splice-sexp-killing-backward
          "M-{" sp-splice-sexp-killing-forward)
         ;; Turn off balancing of single and back quote in lisp.
         (with-eval-after-load 'smartparens
           (sp-with-modes sp--lisp-modes
             (sp-local-pair "'" nil :actions nil)
             (sp-local-pair "`" nil :actions nil))))
     #+end_src
*** Scheme
    #+begin_src emacs-lisp
      (setup scheme
        (:bind "<backtab>" hall-toggle-other-file
               "<C-iso-lefttab>" hall-view-test-log))
    #+end_src
**** Guile-Hall helper functions
     Helper function for [[https://gitlab.com/a-sassmannshausen/guile-hall][guile-hall]], or technically any scheme project
     that have their tests in a =tests= directory and generates a =.log=
     file.

     #+begin_src emacs-lisp
       (defun hall-toggle-other-file ()
         "Switch between file named the same in the project.
       Useful for switching between test and code."
         (interactive)
         (let* ((file (buffer-file-name))
                (filename (file-name-nondirectory file))
                (other-files
                 (seq-filter (lambda (it) (and (string-suffix-p filename it) (not (string= file it))))
                             (project-files (project-current nil)))))
           (if other-files
               (find-file (car other-files))
             (error "No other %s found" filename))))
     #+end_src

     #+begin_src emacs-lisp
       (defun hall-view-test-log ()
         "View the test log for the current buffer."
         (interactive)
         (let* ((file (buffer-file-name))
                (ext (file-name-extension file))
                (project (project-current nil))
                (filename (format "%s.%s" (file-name-base file) "log"))
                (other-files (seq-filter
                              (lambda (it)
                                (string-suffix-p
                                 "tests"
                                 (directory-file-name (file-name-directory it))))
                              (directory-files-recursively
                               (car (project-roots project))
                               (regexp-quote filename)))))
           (if other-files
               (view-file (car other-files))
             (error "No %s found" filename))))
     #+end_src

*** C family
    Specific for C, C++ and other in the c family
    - Set indentation to be two spaces.
    - Set the default mode for .h files to be c++-mode
    - Make it easier to work with camelCase words by enabling subword-mode.
    - Add that it will also search src and include directories when
      switching between header and source files.

    Custom style based on gnu for work. See [[https://www.gnu.org/software/emacs/manual/html_node/ccmode/Adding-Styles.html#Adding-Styles][adding-styles]] for more
    info how this work. [[https://www.gnu.org/software/emacs/manual/html_node/ccmode/Guessing-the-Style.html][Guessing]] the style also work, but it was
    easier for me to just place the pointer at a location and press
    C-c C-o (c-set-offset) and add that to the c-offsets-alist.

    When in a c family buffer use shift tab to switch between header
    and source.

    #+begin_src emacs-lisp
      (c-add-style "dd"
                   '("gnu"
                     (c-basic-offset . 2)
                     (c-offsets-alist
                      (substatement-open . 0)
                      (arglist-close . 0)
                      (arglist-intro . +)
                      (statement-case-open . 0)
                      (brace-list-intro . +))))
    #+end_src
    #+begin_src emacs-lisp
      (setup cc-mode
        (:with-mode c++-mode
          (:file-match "\\.h\\'"))
        ;; Call everytime an c-mode-common file is opened
        (:with-mode c-mode-common
          (:hook (lambda ()
                   ;; Set keybinding for all cc-modes
                   (local-set-key  (kbd "<backtab>") 'ff-find-other-file)
                   (local-set-key  (kbd "<C-iso-lefttab>") 'ff-extension-other-impl)
                   (setq indent-tabs-mode nil)
                   (c-set-style "dd")
                   ;; enable camelCase
                   (subword-mode 1))))
        (:option ff-search-directories '("." "../src" "../include")))
    #+end_src
*** Docker
    #+begin_src emacs-lisp
      (setup dockerfile-mode)
    #+end_src
*** Python
    Package name is python but the mode is python-mode
    Set indentation to 2 white spaces.

    Set the default for pb2 files (=PROJECT=) to use python.
    #+begin_src emacs-lisp
      (setup python
        (:file-match "\\.py\\'" "PROJECT$")
        (:hook (lambda ()
                 (setq indent-tabs-mode nil
                       python-indent-offset 4))))
    #+end_src

    #+begin_src emacs-lisp
      (setup jinja2)
    #+end_src
*** Rust

    Packages for setting up a rust environment
    #+begin_src emacs-lisp
      (setup rust-mode)
    #+end_src

    Mode for editing Cargo files.
    #+begin_src emacs-lisp
      (setup toml-mode)
    #+end_src

*** Golang
    Setting up go to use 2 spaces as indentation and enable
    autocomplete for go.
    #+begin_src emacs-lisp
      (setup go
        (:local-set tab-width 2
                    standard-indent 2
                    indent-tabs-mode nil))
    #+end_src
*** Shaders
**** GLSL
     Set files associated with glsl to use glsl mode
     #+begin_src emacs-lisp
       (setup glsl
         (:file-match "\\.vert\\'"
                      "\\.frag\\'"
                      "\\.geom\\'"
                      "\\.prog\\'"
                      "\\.glsl\\'"))
     #+end_src
*** Build
**** Makefile
     Set following files to use makefile-gmake-mode as the default.
     - Files that starts with =Makefile=.
     - Has extension =.mk=.

     Show trailing whitespace as those can mess up make pretty bad.
     #+begin_src emacs-lisp
       (setup make-mode
         (:with-mode makefile-gmake-mode
           (:file-match "Makefile.*" "\\.mk$"))
         (:with-mode makefile-mode
           ;; Always show trailing whitespace for Makefiles
           ;; Don't break words
           (:local-set show-trailing-whitespace t
                       word-wrap t)))
     #+end_src
**** CMake
     #+begin_src emacs-lisp
       (setup cmake-mode)
     #+end_src
*** REPL
**** Geiser
     #+begin_src emacs-lisp
       (setup geiser
         (:hook-into scheme-mode)
         (:option geiser-default-implementation 'guile
                  geiser-repl-use-other-window nil))
     #+end_src
**** Sh
     Indent using 2 spaces for shell scripts.
     #+begin_src emacs-lisp
       (setup sh
         (:local-set indent-tabs-mode nil
                     c-basic-offset 2))
     #+end_src
*** Yaml
    #+begin_src emacs-lisp
      (setup yaml-mode
        (:hook dotemacs-show-trailing-whitespace-if-writable))
    #+end_src
*** json
    #+begin_src emacs-lisp
      (setup json-mode
        (:hook dotemacs-show-trailing-whitespace-if-writable)
        (:local-set js-indent-level 2))
    #+end_src
*** Markdown
    #+begin_src emacs-lisp
      (setup markdown-mode
        (:hook dotemacs-show-trailing-whitespace-if-writable))
    #+end_src
*** Meson
   #+begin_src emacs-lisp
     (setup meson-mode)
   #+end_src
*** Julia
    #+begin_src emacs-lisp
      (setup julia-mode)
    #+end_src
*** Systemd
    #+begin_src emacs-lisp
      (setup systemd)
    #+end_src
*** GDB script
    #+begin_src emacs-lisp
      (setup gud-script
        (:file-match "\\.gdbinit$"))
    #+end_src
*** lua
    #+begin_src emacs-lisp
      (setup lua-mode)
    #+end_src
** Programs
  Packages that communicates with external processes.
*** Ledger
   Settings for ledger.
   Set the default mode for .dat files to ledger.

   Clean the buffer with C-c C.

   #+begin_src emacs-lisp
     (setup ledger-mode
       (:bind "C-c C" ledger-mode-clean-buffer
              "C-c C-C" plt/ledger-clear-all
              "C-c y" plt/ledger-yank-previous-payee)
       (:file-match "\\.dat\\'")
       (:hook ledger-flymake-enable)
       ;; Workaround for issue described in https://github.com/oantolin/orderless/issues/52
       (:hook (lambda () (setq-local orderless-smart-case nil)))
       (:option ledger-clear-whole-transactions 1
                ledger-schedule-file "~/projects/bokforing/schedule.ledger"
                ledger-schedule-look-backward 5
                ledger-schedule-look-forward 30
                ledger-complete-in-steps t
                ledger-amount-regex
                (concat "\\(  \\|\t\\| \t\\)[ \t]*-?"
                        "(?"
                        "\\(?:"
                        "\\([A-Z$€£₹_(]+ *\\)?"
                        ;; We either match just a number after the commodity with no
                        ;; decimal or thousand separators or a number with thousand
                        ;; separators.  If we have a decimal part starting with `,'
                        ;; or `.', because the match is non-greedy, it must leave at
                        ;; least one of those symbols for the following capture
                        ;; group, which then finishes the decimal part.
                        "\\(-?\\(?:[0-9]+\\|[0-9,.]+?\\)\\)"
                        "\\([,.][0-9)]+\\)?"
                        "\\( *[[:word:]€£₹_\"]+\\)?"
                        "\\(?:[ \t]*[+*/-][ \t]*\\)?"
                        "\\)+"
                        ")?"
                        "\\([ \t]*[@={]@?[^\n;]+?\\)?"
                        "\\([ \t]+;.+?\\|[ \t]*\\)?$")))
   #+end_src

   #+begin_src emacs-lisp
     (defun plt/ledger-clear-all ()
       "Mark all xacts as cleared from point to end of buffer.
     If region is active it will only clear those that are inside."
       (interactive)
       (save-mark-and-excursion
         (let ((bounds (if (use-region-p) (cons (region-beginning) (region-end))
                         (cons (point) (point-max)))))
           (goto-char (car bounds))
           (ledger-navigate-beginning-of-xact)
           (when (and (>= (point) (car bounds)) (not (ledger-transaction-state)))
             (ledger-toggle-current))
           (while (and (ledger-navigate-next-uncleared) (< (point) (cdr bounds)))
             (ledger-toggle-current)))))
   #+end_src

   #+begin_src emacs-lisp
     (defun plt/ledger-yank-previous-payee ()
       "Insert the payee of the previous xact."
       (interactive)
       (insert
        (save-mark-and-excursion
          (let ((payee-regex (rx bol
                                 ;; date
                                 (= 4 digit) (= 2 (: (or "/" "-") (= 2 digit)))
                                 ;; clearing status
                                 (+ blank) (: (* (or "+" "-" "*"))) (+ blank)
                                 ;; payee
                                 (group (* not-newline)))))
            (ledger-navigate-prev-xact-or-directive)
            (search-forward-regexp payee-regex nil t)
            (match-string 1)))))
   #+end_src
*** direnv
    #+begin_src emacs-lisp
      (setup direnv
       (direnv-mode))
    #+end_src
*** Emprise
    #+begin_src emacs-lisp
      (setup emprise)
    #+end_src

    #+begin_src emacs-lisp
      (setup marginalia-emprise
        (eval-after-load 'emprise
          '(eval-after-load 'marginalia
             '(add-to-list 'marginalia-annotator-registry '(emprise marginalia-emprise-annotate)))))
    #+end_src

*** Magit
    A Git porcelain inside Emacs
    Key =C-x g= to run magit on current buffer.

    #+begin_src emacs-lisp
      (setup transient)
    #+end_src

    #+begin_src emacs-lisp
      (setup magit
        (:global "C-x g" magit-status)
        (:with-mode git-commit-setup
          (:hook git-commit-turn-on-flyspell))
        ;; From https://takeonrules.com/2021/08/03/using-magit-built-in-functions-for-workflow/
        (:option magit-repolist-columns
              '(("Name"    25 magit-repolist-column-ident ())
                ("Version" 25 magit-repolist-column-version ())
                ("D"        1 magit-repolist-column-dirty ())
                ("⇣"      3 magit-repolist-column-unpulled-from-upstream
                 ((:right-align t)
                  (:help-echo "Upstream changes not in branch")))
                ("⇡"        3 magit-repolist-column-unpushed-to-upstream
                 ((:right-align t)
                  (:help-echo "Local changes not in upstream")))
                ("Path"    99 magit-repolist-column-path ()))))
    #+end_src
*** The Silver Searcher
    #+begin_src emacs-lisp
      (setup ag
        (:needs "ag"))
    #+end_src
*** notmuch

    Using notmuch to index my emails.
    #+begin_src emacs-lisp
      (setup notmuch
        (:needs "notmuch" "msmtp")
        (:global "C-c m" notmuch
                 "C-c M" home-mail-refresh)
        (:with-mode notmuch-search-mode
          (:bind "l" (lambda (&optional beg end)
                       "mark thread as read"
                       (interactive (notmuch-search-interactive-region))
                       (notmuch-search-tag (list "-unread") beg end)
                       (notmuch-search-next-thread))))
        (:option
         sendmail-program "msmtp"
         send-mail-function 'sendmail-send-it
         mail-specify-envelope-from t
         message-sendmail-envelope-from 'header
         mail-envelope-from 'header
         message-kill-buffer-on-exit t
         message-send-mail-function 'sendmail-send-it
         message-signature "s/Fred[re]+i[ck]+/Fredrik/g"
         mm-text-html-renderer 'w3m
         notmuch-always-prompt-for-sender t
         notmuch-show-indent-messages-width 0
         notmuch-search-oldest-first nil
         notmuch-fcc-dirs `((,user-mail-address . "posteo/Sent"))
         notmuch-show-logo nil
         notmuch-draft-folder "posteo/Drafts"
         notmuch-saved-searches
         '((:name "inkorgen" :query "tag:inbox" :sort-order newest-first :key "i")
           (:name "inkorgen (oläst)" :query "tag:unread and tag:inbox" :sort-order newest-first :key "O")
           (:name "oläst" :query "tag:unread" :sort-order newest-first :key "o")
           (:name "reklam" :query "tag:reklam and tag:unread" :key "r")
           (:name "stjärnmärkt" :query "tag:flagged" :key "f")
           (:name "skickat" :query "tag:sent" :sort-order newest-first :key "s")
           (:name "utkast" :query "tag:draft" :key "u")
           (:name "order" :query "tag:order" :key "b")
           (:name "allt" :query "*" :key "a"))))
    #+end_src

*** pdftools
    #+begin_src emacs-lisp
      (setup (:require pdf-tools)
        (:with-mode pdf-view-mode
          (:file-match "\\.pdf\\'")
          ;; (:hook pdf-view-midnight-minor-mode)
          )
        (:option pdf-view-midnight-colors `("#ddd" . "#111")))
    #+end_src
*** man
    #+begin_src emacs-lisp
      (setup man
        (when dotemacs-is-work
          (:option manual-program "pk man")))
    #+end_src
*** telegram
    #+begin_src emacs-lisp
      (unless dotemacs-is-work
        (setup telega))
    #+end_src
*** vterm

    Workaround for killing text in vterm to the kill ring.
    #+begin_src emacs-lisp
      (defun vterm-send-C-k ()
        "Send `C-k' to libvterm."
        (interactive)
        (kill-ring-save (point) (vterm-end-of-line))
        (vterm-send-key "k" nil nil t))
    #+end_src

    Sometimes I need to run ~emacs~ inside of ~vterm~, and cannot use
    the normal ~C-x C-c~ command to exit as that will exit my real
    emacs session.
    #+BEGIN_SRC emacs-lisp
      (defun vterm-exit-emacs ()
        "Send `C-x C-c' to libvterm.

      Useful when running emacs inside of an vterm"
        (interactive)
        (vterm-send-C-x)
        (vterm-send-C-c))
    #+END_SRC

    #+begin_src emacs-lisp
      (setup vterm
        (:bind "<f8>" vterm-clear
               "C-k" vterm-send-C-k)
        (:local-set
         vterm-max-scrollback 10000
         (append vterm-eval-cmds) '("update-pwd" (lambda (path) (setq default-directory path)))))
    #+end_src
*** IRC
    #+begin_src emacs-lisp
      (setq erc-server "irc.libera.chat"
            erc-nick "plattfot"
            erc-track-shorten-start 8
            erc-autojoin-channels-alist '(("irc.libera.chat" "#guix" "#emacs"))
            erc-kill-buffer-on-part t
            erc-auto-query 'bury)
    #+end_src
** Web
  Packages for webbased content.
*** nginx
    Major mode for editing nginx.
    #+begin_src emacs-lisp
      (setup nginx-mode)
    #+end_src
*** elpher
    #+begin_src emacs-lisp
      (setup elpher)
    #+end_src
** Emacs
  Packages that augments emacs.
*** All the Icons
    #+begin_src emacs-lisp
    (setup (:require all-the-icons))
    #+end_src
*** Org

    Use a little downward-pointing arrow instead of the usual ellipsis
    (=...=) when folded.

    Use syntax highlighting in source blocks while editing
    =org-src-fontify-natively=.

    The variable =org-directory= is set in =.custom.el=, as it changes
    from computer to computer at the moment.

    #+begin_src emacs-lisp
      (defun plt/org-fetch-agenda-files ()
          "Return a list of all files that should be in the agenda."
          (split-string
           (thread-last (expand-file-name "roam" org-directory)
             (format (string-join
                      '("rg -l"
                        "-e TODO"
                        "-e WAIT"
                        "-e CANCELLED"
                        "-e '%%\\(org'"
                        "-e '^[[:blank:]]+<[[:digit:]]{4}'"
                        "--"
                        "%s")
                      " "))
             (shell-command-to-string)
             (string-trim-right))
           "\n"))
    #+end_src

    #+begin_src emacs-lisp
      (defun plt/org-agenda-refresh-files ()
          "Update `org-agenda-files'."
          (interactive)
          (setf org-agenda-files (plt/org-fetch-agenda-files)))
    #+end_src

    #+begin_src emacs-lisp
      (setup org
        (:file-match "\\.org\\'")
        (:global "C-c l" org-store-link
                 "C-c a" org-agenda)
        (:bind "C-M-i" completion-at-point)
        ;; Make sure the agenda files are up to date when rebuilding
        (advice-add 'org-agenda-redo-all :before 'plt/org-agenda-refresh-files)
        (:hook dotemacs-show-trailing-whitespace)
        ;; Workaround from https://orgmode.org/manual/Conflicts.html
        (:hook
         (lambda ()
           (setq-local yas/trigger-key [tab])
           (define-key yas/keymap [tab] 'yas/next-field-or-maybe-expand)))
        ;; Use emacs to view pdfs (shadows the old value)
        (add-to-list 'org-file-apps (cons "\\.pdf\\'" 'emacs))
        ;; Open links in same frame
        (add-to-list 'org-link-frame-setup (cons 'file 'find-file))
        (:option
         org-agenda-files (plt/org-fetch-agenda-files)
         org-agenda-restore-windows-after-quit t
         org-agenda-span 'day
         org-agenda-window-setup 'only-window
         org-confirm-babel-evaluate nil
         org-default-notes-file (expand-file-name "Anteckningar.org" org-directory)
         org-display-remote-inline-images 'cache
         org-ellipsis "⤵"
         org-enforce-todo-dependencies t
         org-format-latex-options (plist-put org-format-latex-options :scale 2.0)
         org-hide-emphasis-markers t
         org-link-search-must-match-exact-headline nil
         org-log-into-drawer "LOGBOOK"
         org-pretty-entities t
         org-pretty-entities-include-sub-superscripts t
         org-use-sub-superscripts '{}
         org-src-fontify-natively t
         org-src-tab-acts-natively t
         org-src-window-setup 'split-window-below
         org-todo-keywords '((sequence "TODO(t)" "WAIT(w@/!)" "|" "DONE(d!)" "CANCELLED(c@)")))
        (when (not dotemacs-is-work)
          (add-to-list 'org-agenda-files org-directory))
        ;; Active Babel languages
        (if dotemacs-is-work
            (org-babel-do-load-languages
             'org-babel-load-languages
             '((calc . t)
               (python . t)
               (scheme . t)))
          (org-babel-do-load-languages
           'org-babel-load-languages
           '((calc . t)
             (python . t)
             (scheme . t)
             (shell . t)
             (C . t)))))
    #+end_src
**** Automate commit todo changes in git

     Commit a todo change to git using =plt/org-todo-commit-change=
     *NOTE* Work in progress. Right now it supports single todo changes
     (incl repeating).

     #+begin_src emacs-lisp
       (require 'tig)

       (defun plt/org-todo-commit--message (diff)
         "Parse DIFF and return commit message.
       If no commit message could be extracted return nil."
         (with-temp-buffer
           (insert diff)
           (diff-mode)
           (let (message)
             (catch 'done
               (save-match-data
                 (progn
                   (goto-char (point-min))
                   (diff-beginning-of-hunk t)
                   (when (and (re-search-forward
                               (rx line-start "-" (one-or-more (in blank)) ":LAST_REPEAT:") nil t)
                              (re-search-forward
                               (rx line-start "+" (one-or-more (in blank)) ":LAST_REPEAT:") nil t))
                     (when (re-search-backward
                            (rx line-start blank (one-or-more (in "*")) (zero-or-more blank) "TODO"
                                (zero-or-more (in blank))
                                (group (zero-or-more (in print))))
                            nil t)
                       (setf message (format "done: %s" (match-string 1)))
                       (throw 'done "done with commit"))))
                 (progn
                   (goto-char (point-min))
                   (diff-beginning-of-hunk t)
                   (when (re-search-forward
                          (rx line-start "+" (one-or-more "*") (zero-or-more blank)
                              ;; TODO: dynamically add these
                              (group (| "TODO" "WAIT" "DONE" "CANCELLED"))
                              (zero-or-more (in blank))
                              (group (zero-or-more (in print))))
                          nil t)
                     (setf message (format "%s: %s" (downcase (match-string 1)) (match-string 2)))
                     (throw 'done "done with commit")))))
             message)))

       (defun plt/org-todo-commit-change ()
         "Commit todo state change"
         (interactive)
         (when-let ((default-directory (car (project-roots (project-current nil)))))
           (-each (--map (oref it :path) (tig-git-status))
             (lambda (note-file)
               (when-let ((message (plt/org-todo-commit--message
                                    (shell-command-to-string (format "git diff %S" note-file)))))
                 (shell-command
                  (format "git add %S && git commit -m %S" note-file
                          (thread-last message
                            ;; Remove links
                            (replace-regexp-in-string
                             (rx "[[" (+? graph) "]["
                                 (group (+? (any graph blank))) "]]") "\\1")
                            ;; Remove trailing tags
                            (replace-regexp-in-string
                             (rx (one-or-more blank) ":" (one-or-more graph) ":" eol) "")))))))))
     #+end_src
**** Notmuch integration
     Enable linking notmuch emails in org
     #+begin_src emacs-lisp
       (setup (:require ol-notmuch))
     #+end_src
**** Man integration
     Enable linking manpages in org
     #+begin_src emacs-lisp
       (setup (:require ol-man))
     #+end_src

**** Custom org templates

     The org structure template el (expand using <el) is from
     [[https://github.com/freetonik/emacs-dotfiles/blob/master/init.org#org][EmacsCast]].

     #+begin_src emacs-lisp
       (setup (:require org-tempo)
         (add-to-list 'org-structure-template-alist '("el" . "src emacs-lisp"))
         (add-to-list 'org-structure-template-alist '("pyo" . "src python :results output")))
     #+end_src
**** Agenda
     #+begin_src emacs-lisp
       (setup org-agenda
         (:with-mode org-agenda-finalize
           (:hook (lambda () (cd org-roam-directory))))
         (:option
          org-agenda-prefix-format '((agenda . " %-2i %?-12t% s")
                                     (todo . " %-2i ")
                                     (tags . " %i ")
                                     (search . " %i "))
          org-agenda-category-icon-alist
           `(
             ("backup" ,(list (all-the-icons-material "backup" :height 1.2)) nil nil :ascent center)
             ("bug" ,(list (all-the-icons-octicon "bug" :height 1.2)) nil nil :ascent center)
             ("computer" ,(list (all-the-icons-faicon "server" :height 1.2)) nil nil :ascent center)
             ("economy" ,(list (all-the-icons-material "euro_symbol" :height 1.2)) nil nil :ascent center)
             ("emacs" ,(list (all-the-icons-fileicon "emacs" :height 1.2)) nil nil :ascent center)
             ("exercise" ,(list (all-the-icons-material "fitness_center" :height 1.2)) nil nil :ascent center)
             ("home" ,(list (all-the-icons-faicon "home" :height 1.2)) nil nil :ascent center)
             ("keyboard" ,(list (all-the-icons-material "keyboard" :height 1.2)) nil nil :ascent center)
             ("misc" ,(list (all-the-icons-octicon "inbox" :height 1.2)) nil nil :ascent center)
             ("photo" ,(list (all-the-icons-material "camera_roll" :height 1.2)) nil nil :ascent center)
             ("project" ,(list (all-the-icons-faicon "flask" :height 1.2)) nil nil :ascent center)
             ("task" ,(list (all-the-icons-faicon "question-circle-o" :height 1.2)) nil nil :ascent center)
             )))
     #+end_src

**** Super agenda
     The =org-agenda-prefix-format= is taken from [[https://github.com/m-cat/init.el/blob/master/init.el#L2082][m-cat's init.el]] and
     removes file name and category. No need to see the file name as
     everything is in the same file.

     #+begin_src emacs-lisp
       (setup org-super-agenda
         (with-eval-after-load 'org
           (progn
             (defun plt-strip-org-agenda-header (header)
               "Remove todo, priority and tags from HEADER."
               ;; Hardcode the todo keywords as I cannot figure out how to use
               ;; them from `org-todo-keywords'. But something causing it to
               ;; expand to empty when passing it via the :transformer.
               (let* ((remove-re (rx (or "TODO" "WAIT" "CANCELLED" "DONE" ;; todo
                                         (seq"[#"(any "A" "B" "C")"]") ;; priority
                                         (seq ":" (+ (any ":" alnum)) (+":")) ;; tags
                                         )))
                      ;; Need to split it in two, otherwise the filter will
                      ;; remove the icons in the prefix.
                      (prefix (substring header 0 14))
                      (rest (->> (substring header 14)
                                 (s-split " ")
                                 (--filter (not (s-matches? remove-re it)))
                                 (s-join " " )
                                 (s-trim-right ))))
                 (s-concat prefix rest)))
             (:option org-super-agenda-groups
                      '((:name "Idag"
                               :time-grid t)
                        (:name "Klart" :todo ("DONE" "CANCELLED") :order 200
                               :transformer plt-strip-org-agenda-header)
                        (:name "Avakta" :todo "WAIT" :order 100
                               :transformer plt-strip-org-agenda-header)
                        (:name "Låg prio" :priority "B" :order 50
                               :transformer plt-strip-org-agenda-header)
                        (:name "Tid över" :priority "C" :order 40
                               :transformer plt-strip-org-agenda-header)
                        (:name "Hög prio" :priority "A" :order 10
                               :transformer plt-strip-org-agenda-header)
                        (:name "Projekt" :tag "projekt" :order 6
                               :transformer plt-strip-org-agenda-header)
                        (:name "Att göra" :todo "TODO" :order 5
                               :transformer plt-strip-org-agenda-header)
                        (:name "Årsdagar" :tag "årsdag" :order 1
                               :transformer plt-strip-org-agenda-header)
                        ))
             (org-super-agenda-mode))))
     #+end_src
**** Org-roam
     "A plain-text personal knowledge management system" - [[https://www.orgroam.com/][orgroam.com]]
     #+begin_src emacs-lisp
       (setup org-roam
         (:global "C-c v r" org-roam-buffer-toggle
                  "C-c v f" org-roam-node-find
                  "C-c v i" org-roam-node-insert)
         (:option
          org-roam-v2-ack t
          org-roam-directory (concat (file-name-as-directory org-directory) "roam")
          org-roam-capture-templates
          '(
            ("d" "default" plain "%?"
             :if-new (file+head "%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}
       ")
             :unnarrowed t)
            ("t" "task" plain "* TODO ${title}
         SCHEDULED: %t
         :PROPERTIES:
         :CATEGORY: %(completing-read \"Category: \" org-agenda-category-icon-alist)
         :END:
         %?
         %a"
             :if-new (file+head "%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}
       ,#+filetags: :uppgift:
       ")
             :empty-lines-before 1
             :unnarrowed t)
            ("n" "node" plain "
       ,#+begin_quote
       %? ---
       ,#+end_quote
       "
             :if-new (file+head "%<%Y%m%d%H%M%S>-${slug}.org"
                                ":PROPERTIES:
       :URL:      %(read-string \"Url: \")
       :END:
       ,#+title: ${title}")
             :empty-lines-before 1
             :unnarrowed t)
            ("b" "band" plain "
       ,#+begin_quote
       %? ---
       ,#+end_quote
       %a
       "
             :if-new (file+head "%<%Y%m%d%H%M%S>-${slug}.org"
                                ":PROPERTIES:
       :URL:      %(read-string \"Url: \")
       :END:
       ,#+title: ${title}
       ,#+filetags: :band:")
             :empty-lines-before 1
             :unnarrowed t)
            ("a" "album" plain "
       ,* [[id:2580937e-3dc4-4bc9-ba61-d718655b12ae][Vinyl]]
         - Artist: %?
         - Färg: 
         - Signerad: %^{Signerad: |Nej|Ja}
         - Inkl CD: %^{Inkl CD: |Nej|Ja}
         - Skivbolag: 
         - Typ: %^{Omslagstyp: |Gatefold|Sleeve}
         - Skivor: 2
         - Övrigt:
       "
             :if-new (file+head "%<%Y%m%d%H%M%S>-${slug}.org"
                                "#+title: ${title}
       ,#+filetags: :album:")
             :empty-lines-before 1
             :unnarrowed t)
            ("D" "datordel" plain "* Senast observerade plats
       %?
       "
             :if-new (file+head "%<%Y%m%d%H%M%S>-${slug}.org"
                                ":PROPERTIES:
       :URL:      %(read-string \"Url: \")
       :END:#+title: ${title}
       ,#+filetags: :datordel:")
             :empty-lines-before 1
             :unnarrowed t)
            ("ö" "öl" plain "
       ,#+begin_quote
       %? ---
       ,#+end_quote

       ,* Omdöme
       "
             :if-new (file+head "%<%Y%m%d%H%M%S>-${slug}.org"
                                ":PROPERTIES:
       :URL:      %(read-string \"Url: \")
       :ABV:      %(read-string \"Abv: \")
       :END:
       ,#+title: ${title}
       ,#+filetags: :öl:")
             :empty-lines-before 1
             :unnarrowed t)))
         (org-roam-db-autosync-mode))
     #+end_src
**** Org-ref

     Dependency of =org-ref=, would have just put the settings in the
     =org-ref= block. But if the =:bind= is placed there it will break
     =ivy-bibtex=.

     #+begin_src emacs-lisp
       (setup ivy-bibtex
         (:global "C-c b" ivy-bibtex)
         (:option bibtex-completion-bibliography `(,plt/paper-bibtex)
                  bibtex-completion-library-path `(,plt/paper-directory)
                  bibtex-completion-notes-path org-roam-directory
                  bibtex-completion-notes-template-multiple-files (format"\
              ,#+TITLE: ${title}
              ,#+ROAM_KEY: cite:${=key=}
              ,* Notes
              :PROPERTIES:
              :Custom_ID: ${=key=}
              :NOTER_DOCUMENT: %s${=key=}.pdf
              :AUTHOR: ${author-abbrev}
              :JOURNAL: ${journaltitle}
              :DATE: ${date}
              :YEAR: ${year}
              :DOI: ${doi}
              :URL: ${url}
              :END:

              " (file-name-as-directory plt/paper-directory))))
     #+end_src

     Integrate bibtex handling and other useful technical writing
     features to org-mode.

     **NOTE:**
     The =(setf wt/orcb-%-replacement-string orcb-%-replacement-string)=
     Is workaround for some bug in the code when it downloads papers.

     #+begin_src emacs-lisp
       (setup org-ref
         (:option org-ref-bibliography-notes org-roam-directory
                  org-ref-default-bibliography `(,plt/paper-bibtex)
                  org-ref-pdf-directory plt/paper-directory
                  reftex-default-bibliography org-ref-default-bibliography))
     #+end_src
     Settings based on [[https://rgoswami.me/posts/org-note-workflow/#org-noter][An Orgmode Note Workflow]]
**** Prettify org

     Use pretty bullet points instead of asterisk
     #+begin_src emacs-lisp
       (setup org-bullets
         (:with-mode org-mode
           (:hook (lambda () (org-bullets-mode t)))))
     #+end_src

     *NOTE:*
     "Doesn't work with yasnippet getting:
     yas--fallback: yasnippet fallback loop!"

     This can happen when you bind ‘yas-expand’ outside of the
     ‘yas-minor-mode-map’.

*** Buffer move
    Move buffers around between windows
    #+begin_src emacs-lisp
      (setup buffer-move
        (:global "<M-S-up>"    buf-move-up
                 "<M-S-down>"  buf-move-down
                 "<M-S-left>"  buf-move-left
                 "<M-S-right>" buf-move-right))
    #+end_src
*** Dired
    Settings for dired.
    Source for the afs-dired-find-file function: [[https://stackoverflow.com/questions/1110118/in-emacs-dired-how-to-find-visit-multiple-files][Source]]
    #+begin_src emacs-lisp
      (setup dired
        ;; Map plt/dired-find-file to F
        (:bind "F" plt/dired-find-file)
        (defun plt/dired-find-file (&optional arg)
             "Open each of the marked files, or the file under the
           point, or when prefix arg, the next N files "
             (interactive "P")
             (seq-each 'find-file (dired-get-marked-files nil arg))))
    #+end_src
*** Diff

    Enable whitespace mode for diff-mode to see trailing whitespace in
    diffs.
    #+begin_src emacs-lisp
      (setup diff
        (:hook whitespace-mode))
    #+end_src
*** Ediff
    #+begin_src emacs-lisp
      (setup ediff
        (:option ediff-window-setup-function 'ediff-setup-windows-plain))
    #+end_src
*** Eshell
    Using some eshell settings from [[https://github.com/howardabrams/dot-files/blob/master/emacs-eshell.org][Howard Abrams]].

    #+begin_src emacs-lisp
      (setup eshell
        (:option eshell-prompt-function
         (lambda ()
           (let* ((pwd (eshell/pwd))
                  (remote (file-remote-p pwd))
                  (remote-name (when remote (cadr (split-string remote ":")))))
             (format "⎣%s%s%s %s⎦ "
               (propertize (user-login-name) 'face '(:foreground "#3387cc"))
               (propertize "@" 'face `(:foreground ,(if remote "#f9fd75" "#ddd")))
               (propertize (or remote-name (system-name)) 'face '(:foreground "#ddd"))
               (propertize (file-name-base
                            (abbreviate-file-name
                             (if remote (string-remove-prefix remote pwd) pwd)))
                           'face '(:foreground "#666")))))
         eshell-highlight-prompt nil
         eshell-prompt-regexp "^⎣.*⎦ "
         ;; eshell-buffer-shorthand t ...  Can't see Bug#19391
         eshell-scroll-to-bottom-on-input 'all
         eshell-error-if-no-glob t
         eshell-hist-ignoredups t
         eshell-save-history-on-exit t
         eshell-prefer-lisp-functions nil
         eshell-destroy-buffer-when-process-dies t
         eshell-cmpl-cycle-completions nil)
        (:hook
         (lambda ()
           (eshell/alias "ff" "find-file $1")
           (eshell/alias "ffw" "find-file-other-window $1")
           (eshell/alias "fff" "find-file-other-frame $1")))
        ;; Cannot use :bind to set keys for some reason
        ;; Make up and down navigate the buffer, similar to shell.
        ;; And jump betwen prompts with C-M-{p,n}
        (:hook
         (lambda ()
           (mapc (lambda (key)
                   (define-key eshell-mode-map key nil))
                 '([up] [C-up] [down] [C-down]))
           (define-key eshell-mode-map (kbd "C-M-p") 'eshell-previous-prompt)
           (define-key eshell-mode-map (kbd "C-M-n") 'eshell-next-prompt))))
    #+end_src

    #+begin_src emacs-lisp
      (defun eshell/lcd (&optional directory)
        "Locally cd to a DIRECTORY when on a remote host."
        (if (file-remote-p default-directory)
            (with-parsed-tramp-file-name default-directory nil
              (eshell/cd (tramp-make-tramp-file-name
                          (tramp-file-name-method v)
                          (tramp-file-name-user v)
                          (tramp-file-name-host v)
                          (or directory "")
                          (tramp-file-name-hop v))))
          (eshell/cd directory)))
    #+end_src
    Function taken from this [[https://www.reddit.com/r/emacs/comments/5pziif/cd_to_home_directory_of_server_when_using_eshell/de9olb7][reddit answer]]
*** Eldoc
    #+begin_src emacs-lisp
      (setup eldoc
        (:option eldoc-echo-area-use-multiline-p nil))
    #+end_src
*** Flyspell
    #+begin_src emacs-lisp
      (setup flyspell
        (:bind "<f6>" plt/ispell-change-dictionary)
        (:with-mode org-mode
          (:hook flyspell-mode))
        (:with-mode prog-mode
          (:hook flyspell-prog-mode))
        (:option
         ispell-program-name "aspell"
         aspell-dictionary "en_US-wo_accents"
         ispell-dictionary "en_US-wo_accents")
        (with-eval-after-load 'flyspell
          (progn
            (require 'transient)
            (transient-define-prefix plt/ispell-change-dictionary ()
              "Change dictionary to"
              [("s" "Swedish" plt/ispell-svenska)
               ("u" "English (US)" plt/ispell-en-us)
               ("c" "English (CA)" plt/ispell-en-ca)
               ])
            (defmacro plt/make-ispell-change-dictionary (dictionary &optional prefix)
              "Create function that change ispell dictionary to DICTIONARY.
      PREFIX is an optional name used in the function name, if not set
      it will use the DICTIONARY."
              (list 'defun (intern (format "plt/ispell-%s" (or prefix dictionary))) ()
                    (format "Change ispell dictionary to %s." dictionary)
                    (list 'interactive)
                    (list 'ispell-change-dictionary dictionary)))
            (plt/make-ispell-change-dictionary "svenska")
            (plt/make-ispell-change-dictionary "en_US-wo_accents" "en-us")
            (plt/make-ispell-change-dictionary "en_CA-wo_accents" "en-ca"))))
    #+end_src

    #+begin_src emacs-lisp
      (use-package flyspell-correct
        :bind ("C-;" . flyspell-correct-wrapper))
    #+end_src
*** emms
    Using guix to handle emms, as I need the emms-print-metadata
    function for libtag.
    #+begin_src emacs-lisp
      (setup emms
        (:global "<f9>" emms
                 "<C-f9>" emms-browser)
        (:also-load emms-setup emms-info-libtag)
        (emms-all)
        (:option emms-source-file-default-directory "/media/Valhalla/Music/"
                 emms-source-file-directory-tree-function 'emms-source-file-directory-tree-find
                 emms-browser-covers 'emms-browser-cache-thumbnail-async
                 emms-player-list '(emms-player-mpv)
                 emms-info-functions '(emms-info-libtag)))
    #+end_src
*** ibuffer
     Use ibuffer instead of list-buffers, has some neat features.

     Sort buffers by placing them in different groups. Hide empty
     groups to avoid cluttering the ibuffer.
     #+begin_src emacs-lisp
       (setup ibuffer
         (defalias 'list-buffers 'ibuffer)
         (:hook
          (lambda ()
            ;; Sucks up a lot of cpu time when using projectile
            ;;(ibuffer-auto-mode 1) ;; Keep the ibuffer in sync
            (ibuffer-switch-to-saved-filter-groups "default")))
         (:option ibuffer-expert t ;; Don't ask when closing unmodified buffers
                  ibuffer-show-empty-filter-groups nil
                  ibuffer-saved-filter-groups
                  '(("default"
                     ("c++" (mode . c++-mode))
                     ("scheme" (mode . scheme-mode))
                     ("make"  (or (mode . makefile-gmake-mode)
                                  (mode . makefile-mode)))
                     ("cmake" (mode . cmake-mode ))
                     ("scripts" (mode . sh-mode))
                     ("ag" (mode . ag-mode ))
                     ("ivy" (name . "^\\*ivy-.*$"))
                     ("erc" (mode . erc-mode))
                     ("docs" (or (mode . rst-mode)
                                 (mode . Man-mode)
                                 (mode . markdown-mode)
                                 (mode . org-mode)))
                     ("dired" (mode . dired-mode))
                     ("python" (mode . python-mode))
                     ("yaml" (mode . yaml-mode))
                     ("json" (mode . json-mode))
                     ("jinja" (mode . jinja2-mode))
                     ("vc" (or (mode . vc-dir-mode)
                               (mode . diff-mode)
                               (mode . magit--turn-on-shift-select-mode)
                               (mode . magit-auto-revert-mode)
                               (mode . magit-blame-disable-mode)
                               (mode . magit-blame-disabled-mode)
                               (mode . magit-blame-mode)
                               (mode . magit-blame-put-keymap-before-view-mode)
                               (mode . magit-blob-mode)
                               (mode . magit-cherry-mode)
                               (mode . magit-diff-mode)
                               (mode . magit-file-mode)
                               (mode . magit-log-mode)
                               (mode . magit-log-select-mode)
                               (mode . magit-merge-preview-mode)
                               (mode . magit-popup-mode)
                               (mode . magit-process-mode)
                               (mode . magit-process-unset-mode)
                               (mode . magit-reflog-mode)
                               (mode . magit-refs-mode)
                               (mode . magit-repolist-mode)
                               (mode . magit-revision-mode)
                               (mode . magit-stash-mode)
                               (mode . magit-stashes-mode)
                               (mode . magit-status-mode)
                               (mode . magit-submodule-list-mode)
                               (mode . magit-turn-on-auto-revert-mode)
                               (mode . magit-wip-after-apply-mode)
                               (mode . magit-wip-after-save-local-mode)
                               (mode . magit-wip-after-save-mode)
                               (mode . magit-wip-before-change-mode)))
                     ("shell" (mode . shell-mode))
                     ("gdb" (mode . gdb-script-mode))
                     ("elisp" (mode . emacs-lisp-mode))
                     ("emacs" (name . "^\\*.*?\\*$"))))))
     #+end_src
*** ivy
    Better multi-editing than ag.el.
    See [[https://sam217pa.github.io/2016/09/11/nuclear-power-editing-via-ivy-and-ag/][nuclear weapon multi-editing]]

    #+begin_src emacs-lisp
      (setup ivy
        (:option ivy-count-format "(%d/%d) "))
    #+end_src

**** wgrep
     Power editing with =occur= buffer.
     #+begin_src emacs-lisp
       (setup wgrep)
     #+end_src
*** Orderless
    More powerful completion style than the built in.
    #+begin_src emacs-lisp
      (setup orderless
        ;; https://github.com/minad/vertico/issues/68#issuecomment-873393677
        (defun basic-remote-try-completion (string table pred point)
          (and (vertico--remote-p string)
               (completion-basic-try-completion string table pred point)))
        (defun basic-remote-all-completions (string table pred point)
          (and (vertico--remote-p string)
               (completion-basic-all-completions string table pred point)))
        (add-to-list
         'completion-styles-alist
         '(basic-remote basic-remote-try-completion basic-remote-all-completions nil))
        (:option completion-styles '(orderless)
                 completion-category-overrides '((file (styles basic-remote partial-completion)))))
    #+end_src
*** Vertico

    Small package that adds vertical completion.
    #+begin_src emacs-lisp
      (setup vertico
        (vertico-mode))
    #+end_src
*** Savehist

    #+begin_quote
    Persist history over Emacs restarts. Vertico sorts by history
    position. --- [[https://github.com/minad/vertico][github.com/minad/vertico]]
    #+end_quote

    #+begin_src emacs-lisp
      (setup savehist
        (savehist-mode))
    #+end_src
*** Marginalia

    "This package provides marginalia-mode which adds marginalia to
    the minibuffer completions. [[https://en.wikipedia.org/wiki/Marginalia][Marginalia]] are marks or annotations
    placed at the margin of the page of a book or in this case helpful
    colorful annotations placed at the margin of the minibuffer for
    your completion candidates." - [[https://github.com/minad/marginalia][github.com]]

    #+begin_src emacs-lisp
      (setup marginalia
        (marginalia-mode))
    #+end_src
*** Consult

    Use =consult-imenu= instead of imenu. To avoid hunting down all
    keymaps that defines imenu, easier to just alias the function.

    #+begin_src emacs-lisp
      (setup consult
        (:global "C-M-g" consult-ripgrep
                 "C-c ;" consult-flymake)
        (defalias 'imenu 'consult-imenu))
    #+end_src
*** Embark

    Extension to [[https://github.com/oantolin/embark][embark]] to be able to quickly copy the file name
    associated with a buffer. My old workflow involved =find-file=,
    auto complete the file in question then copy the line. This should
    be a bit faster to use.

    #+begin_src emacs-lisp
      (defun plt/embark--copy-buffer-file-name (buffer file-transform)
        "Add the transformed file name of BUFFER to the `kill-ring'.

      If the buffer has a file name associated to it, otherwise it will
      use the `default-directory' associated with BUFFER.

      By transformed file name, means that it will apply FILE-TRANSFORM
      on the file name and add the result to `kill-ring'."
        (with-current-buffer buffer
          (kill-new (funcall file-transform (or (buffer-file-name) default-directory)))))

      (defun plt/embark-copy-buffer-file-name (buffer)
        "Copy the file name of BUFFER to the `kill-ring'.

      If the buffer has a file name associated to it, otherwise this
      does nothing.

      This will include the remote prefix if BUFFER points to a remote
      file. See `plt/embark-copy-buffer-file-local-name' if you only
      want to copy the filename without the prefix."
        (interactive "bBuffer: ")
        (plt/embark--copy-buffer-file-name buffer 'identity))

      (defun plt/embark-copy-buffer-file-local-name (buffer)
        "Copy only the local part of the filename of BUFFER to the `kill-ring'.

      If the buffer has a filename associated to it, otherwise this
      does nothing.

      See `plt/embark-copy-buffer-file-name' if you want to copy the
      full file name."
        (interactive "bBuffer: ")
        (plt/embark--copy-buffer-file-name buffer 'file-local-name))
    #+end_src

    #+begin_src emacs-lisp
      (use-package embark
        :bind
        (("<f7>" . embark-act)
         :map embark-buffer-map
         ("c" . plt/embark-copy-buffer-file-name)
         ("C" . plt/embark-copy-buffer-file-local-name))
        :custom
        (prefix-help-command #'embark-prefix-help-command)
        :config
        ;; Hide the mode line of the Embark live/completions buffers
        (add-to-list 'display-buffer-alist
                     '("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
                       nil
                       (window-parameters (mode-line-format . none)))))
    #+end_src

    #+begin_src emacs-lisp
      (use-package embark-consult
        :after (embark consult)
        :demand t ; only necessary if you have the hook below
        ;; if you want to have consult previews as you move around an
        ;; auto-updating embark collect buffer
        :hook
        (embark-collect-mode . embark-consult-preview-minor-mode))
    #+end_src
*** Tramp
    Set the ssh to be the default method for tramp.
    If tramp hangs and you are using zsh see [[#tramp-hang-workaround][here]].
    #+begin_src emacs-lisp
      (use-package tramp
        :config
        (setq tramp-default-method "ssh")
        :pin gnu)
    #+end_src
*** Sudo edit
    Sudo edit the current file
    #+begin_src emacs-lisp
      (use-package sudo-edit
        :bind ("C-c C-r" . sudo-edit)
        :pin melpa)
    #+end_src
*** Windmove
    Jump between windows using the arrow keys instead of cycling with
    "C-x o". Note that this Doesn't work in org mode.

    *TIP:* If using i3wm. Use frames instead of windows then use i3's
     navigation instead.
    #+begin_src emacs-lisp
      (use-package windmove
        :bind (([M-left]  . windmove-left)  ; move to left window
               ([M-right] . windmove-right) ; move to right window
               ([M-up]    . windmove-up)    ; move to upper window
               ([M-down]  . windmove-down)) ; move to downer window
        :pin melpa-stable)
    #+end_src
*** Compilation
    Ansi colors in compilation window see [[https://stackoverflow.com/questions/13397737/ansi-coloring-in-compilation-mode][link]]

    Have disabled automatically closing the *compilation* buffer if no
    errors occur. For one the function in [[https://www.emacswiki.org/emacs/ModeCompile#toc2][link]] doesn't properly swap
    to the correct buffer. Usually you end up with multiple frames
    having the same buffer open, which is annoying.

    Second it will close the buffer if only warnings occured. I like
    to have my code warning free and thus I need to see if any
    warnings occured. And cannot force all warnings to be treated as
    errors as others might not share the same idea about warnings.

    #+begin_src emacs-lisp
      (use-package compile
        :init
        ;; Reuse the *compilaiton* window if open if not pick another window
        ;; in another frame.
        (add-to-list 'display-buffer-alist
                     '("^\\*compilation\\*$"
                       (display-buffer-reuse-window display-buffer-use-some-frame)
                       (reusable-frames      . visible)
                       (inhibit-switch-frame . t)
                       (inhibit-same-window  . t)
                       ))
        :config
        (use-package ansi-color)
        (setf compilation-scroll-output t)
        (add-hook 'compilation-filter-hook
                  (lambda ()
                    (toggle-read-only)
                    (ansi-color-apply-on-region compilation-filter-start (point))
                    (toggle-read-only))))
    #+end_src
*** Version Control
    Don't ask when following a symlink to a vc directory.
    #+begin_src emacs-lisp
      (setq vc-follow-symlinks t)
    #+end_src
*** Regexp builder
    Avoid escape-hell with regex builder, can toggle between styles
    with 'C-c <tab>'. See [[https://masteringemacs.org/article/re-builder-interactive-regexp-builder][masteringemacs]] for more info about regex
    builder.

    #+begin_src emacs-lisp
      (use-package re-builder
        :config
        (setq-default reb-re-syntax 'string))
    #+end_src
*** evil
    Vim bindings are a lot easier to use on the phone than normal
    emacs bindings. Enable *evil-mode* when it detects android.
    #+begin_src emacs-lisp
      (use-package evil
        :if (getenv "ANDROID_ROOT")
        :bind (:map evil-normal-state-map ("SPC t" . 'training-popup))
        :config
        (evil-mode 1)
        :pin melpa-stable)
    #+end_src
*** elfeed
    RSS/Atom reader
    #+begin_src emacs-lisp
      (use-package elfeed
        :bind (("C-c n" . 'elfeed)
               :map elfeed-search-mode-map
               ;; Make sure the db is saved
               ("Q" . plt/elfeed-save-db-and-bury)
               ("q" . plt/elfeed-save-db-and-bury)
               ;; Use similar bindings as notmuch
               ("j" . plt/elfeed-jump-popup)
               ("l" . elfeed-search-untag-all-unread)
               ("o" . elfeed-search-tag-all-unread)
               ("t" . (lambda ()
                        (interactive)
                        (-each (elfeed-search-selected)
                          (lambda (entry)
                            (if (member 'later (elfeed-entry-tags entry))
                                (elfeed-untag entry 'later)
                              (elfeed-tag entry 'later))
                            (elfeed-search-update-entry entry)))))
               ;; Mark all as read
               ("L" . (lambda ()
                        (interactive)
                        (mark-whole-buffer)
                        (elfeed-search-untag-all-unread)))
               ;; Mark all as unread
               ("O" . (lambda ()
                        (interactive)
                        (mark-whole-buffer)
                        (elfeed-search-tag-all-unread)))
               ("v" . plt/elfeed-view-mpv)
               ("A" . plt/elfeed-emms-add-url)
               ("d" . plt/elfeed-arxiv-download)
               )
        :config
        (require 'transient)
        (eval-when-compile (require 'elfeed))
        (defun plt/elfeed-youtube-feed (channel-id)
          "Transform CHANNEL-ID to a youtube feed."
          (let ((yt-prefix "https://www.youtube.com/feeds/videos.xml?channel_id="))
            (s-prepend yt-prefix channel-id)))

        (cl-defun plt/elfeed-group-feeds (&key tags feeds (transform 'identity))
          "Add TAGS to the FEEDS.

            TAGS is a list of symbols or just one symbol.

            FEEDS is a list where each element is either an url (string) or a
            list. If the element is a list, then the first element is the url
            and the rest are additional tags.

            TRANSFORM procedure that will be called on each url, by default
            this is `identity'."
          (unless (or (listp tags) (symbolp tags))
            (error "TAGS must be a list of symbols or a symbol"))

          (unless (or (listp feeds) (stringp feeds))
            (error "FEEDS must be a list or a string"))

          (let ((tags (if (listp tags) tags (list tags))))
            (->> feeds
                 (--map (if (listp it)
                            `(,(funcall transform (car it)) ,@tags ,@(cdr it))
                          `(,(funcall transform it) ,@tags))))))

        ;; Based on https://cestlaz.github.io/posts/using-emacs-29-elfeed/
        (defun plt/elfeed-save-db-and-bury ()
          "Wrapper to save the elfeed db to disk before burying buffer"
          (interactive)
          (elfeed-db-save)
          (quit-window))

        (transient-define-prefix plt/elfeed-jump-popup ()
                                 "Jump to"
                                 [("o" "Oläst" plt/elfeed-set-filter-unread)
                                  ("t" "Taggat" plt/elfeed-set-filter-later)
                                  ("r" "Raporter" plt/elfeed-set-filter-paper)
                                  ("R" "Alla rapporter" plt/elfeed-set-filter-all-papers)
                                  ])

        (defmacro plt/make-elfeed-set-filter (name filter)
          "Create function with the prefix NAME to set elfeed FILTER."
          (list 'defun (intern (format "plt/elfeed-set-filter-%s" name)) ()
                (format "Set elfeed filter to %s." filter)
                (list 'interactive)
                (list 'elfeed-search-set-filter filter)))

        (cl-defun plt/elfeed-arxiv-feed (query &key (max_results 300))
          "Create an arXiv atom feed from QUERY.
                        Where QUERY is a list of search terms or just one string.
                        MAX_RESULTS specify the max results in the feed. Search queries
                        can be combined with three booleans AND, OR and ANDNOT. See these
                        links for more info about the search query:
                        https://arxiv.org/help/api/user-manual#Architecture
                        https://arxiv.org/help/api/user-manual#query_details"
          (s-join "&" `(,(format "http://export.arxiv.org/api/query?search_query=%s"
                                 (if (listp query)
                                     (s-join "+" query)
                                   query))
                        "start=0"
                        ,(format "max_results=%s" max_results)
                        "sortBy=submittedDate"
                        "sortOrder=descending")))

        (cl-defstruct (arxiv (:constructor make--arxiv))
          "Structure containing information for an ArXiv feed."
          (url nil :type string)
          (tags nil :type list)
          (title nil :type string))

        (cl-defun make-arxiv (query &key tags title)
          "Construct an <arxiv> struct.
                        Transform the QUERY to an url.
                        TAGS and TITLE are sent verbatim to the struct constructor."
          (make--arxiv :url (plt/elfeed-arxiv-feed query)
                       ;; E.g. "cat:cs.CG" -> 'cg
                       :tags (or tags (intern (downcase (file-name-extension query))))
                       :title title))

        (defconst plt/arxivs `(,(make-arxiv "cat:cs.CG" :title "Computational Geometry")
                               ,(make-arxiv "cat:cs.DS" :title "Data Structures and Algorithms")
                               ,(make-arxiv "cat:cs.DM" :title "Discrete Mathematics")
                               ,(make-arxiv "cat:cs.DC" :title "Distributed, Parallel, and Cluster Computing")
                               ,(make-arxiv "cat:cs.ML" :title "Machine Learning")
                               ,(make-arxiv "cat:cs.PL" :title "Programming Languages")
                               ,(make-arxiv "cat:cs.SE" :title "Software Engineering")
                               ,(make-arxiv "cat:physics.flu-dyn" :title "Fluid Dynamics")
                               ))

        (defun plt/elfeed-search-update-arxiv (&rest args)
          (mapc
           (lambda (it)
             (let ((feed (elfeed-db-get-feed (arxiv-url it))))
               (setf (elfeed-feed-title feed) (arxiv-title it))))
           plt/arxivs))

        (advice-add 'elfeed-search-update :before 'plt/elfeed-search-update-arxiv)

        (let ((time "@6-months-ago"))
          (plt/make-elfeed-set-filter unread (format "%s +unread -paper" time))
          (plt/make-elfeed-set-filter later (format "+later"))
          (plt/make-elfeed-set-filter paper (format "%s +paper +unread" time))
          (plt/make-elfeed-set-filter all-papers (format "%s +paper" time)))

        (add-hook 'elfeed-new-entry-hook
                  (elfeed-make-tagger :before "1 week ago"
                                      :remove 'unread))
        (setf elfeed-search-filter "@6-months-ago +unread -paper"
              elfeed-feeds
              `(,@(plt/elfeed-group-feeds
                   :tags 'fun
                   :feeds '(("https://rebusinla.wordpress.com/feed/" blog)
                            "https://warpdrive.se/rss/"
                            "https://xkcd.com/atom.xml"))
                ,@(plt/elfeed-group-feeds
                   :tags 'cg
                   :feeds '("https://c0de517e.blogspot.com/feeds/posts/default"
                            "https://animationphysics.wordpress.com/feed/"
                            ("https://www.realtimerendering.com/blog/feed/" blog)
                            "https://www.vfxblog.com/feed/"))
                ,@(plt/elfeed-group-feeds
                   :tags 'news
                   :feeds '("https://www.fz.se/rss/fznews_rss20.xml"
                            "https://rss.slashdot.org/Slashdot/slashdot"
                            ("https://www.anandtech.com/rss/" nerd)
                            "https://www.macrumors.com/macrumors.xml"
                            ("https://www.sweclockers.com/feeds/news.xml" nerd)
                            ("https://feeds.arstechnica.com/arstechnica/index/" nerd)
                            "https://www.raspberrypi.org/feed"
                            ("https://feeds.feedburner.com/TheHackersNews" nerd)))
                ,@(plt/elfeed-group-feeds
                   :tags 'linux
                   :feeds '(("https://www.phoronix.com/rss.php" news)
                            ("https://lwn.net/headlines/newrss" news)
                            ("https://www.gnu.org/software/guix/feeds/blog.atom" blog)
                            "https://www.linuxjournal.com/node/feed"
                            "https://www.archlinux.org/feeds/news/"))
                ,@(plt/elfeed-group-feeds
                   :tags 'keebs
                   :feeds '("https://www.reddit.com/r/MechGroupBuys/.rss"
                            "https://www.reddit.com/r/ErgoMechKeyboards/.rss"))
                ,@(plt/elfeed-group-feeds
                   :tags 'photo
                   :feeds '("https://www.dpreview.com/feeds/news.xml"
                            "https://nikonrumors.com/feed"))
                ,@(plt/elfeed-group-feeds
                   :tags 'emacs
                   :feeds '("https://www.reddit.com/r/emacs/.rss"
                            "https://karthinks.com/index.xml"
                            "https://blog.tecosaur.com/tmio/rss.xml"
                            "https://sachachua.com/blog/category/emacs-news/feed/"))
                ,@(plt/elfeed-group-feeds
                   :tags 'deals
                   :feeds '("https://www.reddit.com/r/bapcsalescanada/.rss"))
                ,@(plt/elfeed-group-feeds
                   :tags 'youtube
                   :transform 'plt/elfeed-youtube-feed
                   :feeds '(("UCyaPf0E-PRRZH3UvvxNPeEw" music) ;; Avatar
                            ("UCjR-qXRBNkysQ0Threo1Bfg" music) ;; Blackbriar
                            ("UCMlGfpWw-RUdWX_JbLCukXg" talks) ;; Cppcon
                            ("UC9NuJImUbaSNKiwF2bdSfAw" talks) ;; Fosdem
                            ("UChIs72whgZI9w6d6FhwGGHA" news nerd) ;; Gamers Nexus
                            ("UCAOiVaJJlH0Oduv48NN0mMA" music) ;; Ghost
                            ("UChGDEluRG9r5kCecRAQTx_Q" talks) ;; HackersOnBoard
                            ("UCTp0MnlTlmqC3NdrPzD08EA" news vlog) ;; Infidelamsterdam
                            ("UCv7UOhZ2XuPwm9SN5oJsCjA" news vlog) ;; Intermit.Tech
                            ("UC1T4KJG1L_kTrP9RcdU5Csw" history) ;; Knyght Errant
                            ("UCOWcZ6Wicl-1N34H0zZe38w" nerd linux) ;; Level1Linux
                            ("UC4w1YQAJMWOz4qtxinq55LQ" nerd) ;; Level1Techs
                            ("UC9pgQfOXRsp4UKrI8q0zjXQ" history) ;; Lindybeige
                            ("UCRDQEDxAVuxcsyeEoOpSoRA" nerd) ;; Mark Furneaux
                            ("UC2XMr58U7rZnL4AW0n9Ca8g" music) ;; Orbit Culture
                            ("UCvWWf-LYjaujE50iYai8WgQ" news nerd) ;; Paul's Hardware
                            ("UCjQhd1APsd5NQhiVZV7GYzg" music) ;; Sabaton
                            ("UCaG4CBbZih6nLzD08bTBGfw" history) ;; Sabaton History
                            ("UC3WIohkLkH4GFoMrrWVZZFA" history) ;; Skallagrim
                            ("UCW64r1wPzfj0W1qbzzfCgFg" news nerd) ;; Sweclockers
                            ("UCfK96bDQdSkKFAdqNv0YOmw" nerd fun) ;; Sweclockers Extra
                            ("UCs6vRDdkZ8bP8Xt6WHbvrwA" music) ;; The Hu
                            ("UCoxg3Kml41wE3IPq-PC-LQw" music) ;; Nuclear Blast Records
                            ("UCnK9PxMozTYs8ELOvgMNKFA" music) ;; Century Media Records
                            ("UCSldglor1t-5E-Gy2eBdMrA" music) ;; Metal Blade Records
                            ("UCd4XwUn2Lure2NHHjukoCwA" linux) ;; Linux for Everyone
                            ("UC0NpEEcmONWuTU3nfURmyKw" music) ;; A&P Reacts
                            ("UC0uTPqBCFIpZxlz_Lv1tk_g" talks emacs) ;; Protesilaos Stavrou
                            ("UCAiiOTio8Yu69c3XnR7nQBQ" talks emacs) ;; System Crafters
                            ))
                ,@(plt/elfeed-group-feeds
                   :tags '(paper arxiv)
                   :feeds (--map (list (arxiv-url it) (arxiv-tags it)) plt/arxivs))
                )))
    #+end_src

    Functions based on the blog entry at [[https://joshrollinswrites.com/help-desk-head-desk/20200611/][joshrollinswrites.com]] and the
    [[https://github.com/mpv-player/mpv/blob/master/TOOLS/umpv][umpv]] script in the mpv repo. I.e it will append the =urls= to mpv
    if it is already running. Otherwise it will launch =mpv=.

    **Note**: that it will only append to an mpv instance launched by
    this function.

    #+begin_src emacs-lisp
      (defun plt/elfeed-emms-add-url ()
        "Grab url and add them to emms."
        (interactive)
        (let ((entries (elfeed-search-selected)))
          (->> entries
               (-map #'elfeed-entry-link)
               -non-nil
               (-map 'emms-add-url))
          (-each entries
            (lambda (entry)
              (elfeed-untag entry 'unread)
              (elfeed-search-update-entry entry))))
        (unless (use-region-p) (forward-line)))

      (cl-defun plt/elfeed-mpv (urls &key (socket "/tmp/mpvsocket"))
        "Watch videos from URLS in mpv.

      SOCKET is the name of the unix socket to use when communicate
      with mpv. Default is \"/tmp/mpvsocket\".

      If mpv has already been launched append the URLS to the current
      running process."
        ;; TODO: figure out a way to spawn on connection failure
        (if (file-exists-p socket)
            (let ((proc (make-network-process
                         :name "mpv-client"
                         :family 'local
                         :service socket)))
              (progn
                (--each urls
                  (process-send-string
                   proc
                   (format "raw loadfile %s append\n" it)))
                (message "Added %s to mpv" (s-join ", " urls))
                (delete-process proc)))
          ;; File does not exist - launch mpv with urls
          (progn
            (message "Launching: mpv" (s-join " " urls))
            (async-shell-command (s-join " " `("mpv" ,@(--map (format "%S" it) urls)
                                               "--input-ipc-server=/tmp/mpvsocket"))
                                 "*MPV*")
            ;; Clean up the socket when done
            (set-process-sentinel (get-buffer-process "*MPV*")
                                  (lambda (process event)
                                    (when (eq (process-status process) 'exit)
                                      (delete-file socket)))))))

      ;; Don't show the async buffer
      (add-to-list 'display-buffer-alist
                   '("^\\*MPV\\*$"
                     (display-buffer-no-window)))

      (defun plt/elfeed-view-mpv ()
        "Grab youtube-feed links."
        (interactive)
        (let ((entries (elfeed-search-selected)))
          (->> entries
               (-map #'elfeed-entry-link)
               -non-nil
               plt/elfeed-mpv)
          (-each entries
            (lambda (entry)
              (elfeed-untag entry 'unread)
              (elfeed-search-update-entry entry))))
        (unless (use-region-p) (forward-line)))
    #+end_src

    Make it easy to download pdf's from =paper= feeds using =org-ref=.
    #+begin_src emacs-lisp
      (defun plt/elfeed-arxiv-download ()
        "Grab pdf from arxiv feeds and download them.

      Assumes `org-ref' is setup properly."
        (interactive)
        (-each
            (->> (elfeed-search-selected)
                 (-map #'elfeed-entry-link)
                 (--filter (and (stringp it) (s-prefix? "http://arxiv.org/abs/" it)))
                 (--map (s-chop-prefix "http://arxiv.org/abs/" it)))
          (lambda (id)
            (arxiv-get-pdf-add-bibtex-entry id plt/paper-bibtex plt/paper-directory)))
        (unless (use-region-p) (forward-line)))
    #+end_src
*** mood-line
    #+begin_src emacs-lisp
      (use-package mood-line
        :custom
        (mood-line-show-encoding-information t)
        :config
        (mood-line-mode)
        (defun plt/mood-line-unimportant-encoding (mood-line-fun)
          "Set what MOOD-LINE-FUN return as unimportant"
          (propertize (funcall mood-line-fun) 'face 'mood-line-unimportant))
        (defun plt/mood-line-shell-modified (mood-line-fun)
          "Don't show modification on comint derived and vterm buffers."
          (if (not (derived-mode-p 'comint-mode 'vterm-mode 'erc-mode))
              (funcall mood-line-fun)
            "  "))
        (defun plt/mood-line-remote-status (mood-line-fun)
          "Show an @ before the modified indicator if the buffer is remote."
          (concat
           (if (and default-directory (file-remote-p default-directory))
               (propertize "@" 'face 'mood-line-unimportant)
             " ")
           (funcall mood-line-fun)))
        ;; Workaround to fix errors when using emacs@28.1 and emacs-mood-line@1.2.4
        (setf flymake--mode-line-format flymake-mode-line-format)
        (advice-add 'mood-line-segment-encoding :around 'plt/mood-line-unimportant-encoding)
        (advice-add 'mood-line-segment-modified :around 'plt/mood-line-shell-modified)
        (advice-add 'mood-line-segment-modified :around 'plt/mood-line-remote-status))
    #+end_src
*** w3m
    #+begin_src emacs-lisp
      (use-package w3m)
    #+end_src
** Text
  Packages for editing and viewing text.
*** Emojify

    Need to be able to render emojis properly when reading emails. And
    since emacs in Linux doesn't support Color fonts (yet?) needed for
    it to work with Google's Noto Emoij font. MacOS had support but
    got removed in [[https://github.com/emacs-mirror/emacs/blob/emacs-25.1/etc/NEWS#L1723][25.1]].

    I'll need to use emojify instead.

    #+begin_src emacs-lisp
      (use-package emojify
        :after (notmuch)
        :init
        ;; Enable emojify when searching and reading emails
        (add-hook 'notmuch-search-mode-hook 'emojify-mode)
        (add-hook 'notmuch-show-mode-hook 'emojify-mode)
        (add-hook 'notmuch-message-mode-hook 'emojify-mode)
        :pin melpa-stable)
    #+end_src
*** Rainbow
    Useful when debugging the theme. But is rarely used.
    #+begin_src emacs-lisp
      (use-package rainbow-mode
       	:pin gnu)
    #+end_src
*** Move text
    Move line up and down using arrow keys.
    #+begin_src emacs-lisp
      (use-package move-text
       	:bind (([C-S-up] . move-text-up)
               ([C-S-down] . move-text-down))
       	:pin melpa-stable)
    #+end_src

*** Expand region
    #+begin_src emacs-lisp
      (use-package expand-region
       	:bind ("C-=" . er/expand-region)
       	:pin melpa-stable)
    #+end_src
*** Multiple cursors
    Keybindings for the mc package
    #+begin_src emacs-lisp
      (use-package multiple-cursors
        :bind (("C-S-c C-S-c" . mc/edit-lines)
               ("C->"         . mc/mark-next-like-this)
               ("C-<"         . mc/mark-previous-like-this)
               ("C-c C-<"     . mc/mark-all-like-this)
               ("C-+"         . mc/mark-next-like-this)
               :map mc/keymap
               ("C-c m n"     . mc/insert-numbers)
               ("C-c m c"     . mc/insert-characters)
               ("C-c m s n"   . mc/insert-same-numbers-per-line)
               ("C-c m s c"   . mc/insert-same-chars-per-line))
        :config
        :pin melpa-stable)
    #+end_src

    #+begin_src emacs-lisp
      (use-package mc-extras
        :after (multiple-cursors)
        :pin melpa-stable)
    #+end_src
*** String inflections
    #+begin_src emacs-lisp
      (use-package string-inflection
       	:pin melpa-stable)
    #+end_src
*** Abbrev
    #+begin_src emacs-lisp
      (use-package abbrev
        :delight abbrev-mode)
    #+end_src

*** isearch

    Integrate packages as expand-region with isearch. This function
    comes from issue [[https://github.com/magnars/expand-region.el/issues/17][#17]] on expand-region.el.
    #+begin_src emacs-lisp
      (use-package isearch
        :ensure nil
        :config
        (defun isearch-yank-selection ()
        "Put selection from buffer into search string."
        (interactive)
        (when (use-region-p)
          (deactivate-mark))  ;;fully optional, but I don't like unnecesary highlighting
        (isearch-yank-internal (lambda () (mark))))
        :bind (:map isearch-mode-map ("C-o" . isearch-yank-selection)))
    #+end_src
** Nov
   Epub reader mode.
   #+begin_src emacs-lisp
     (use-package nov
       :mode (("\\.epub\\'" . nov-mode))
       :pin melpa-stable)
   #+end_src
** Shell
   Enable color in shell and define the color theme. Also disable
   yasnippet in shell mode since that's messing with the shell.

   Disabled the comint-highlight-prompt to use the colors from the
   shells prompt. Source: [[https://stackoverflow.com/questions/25819034/colors-in-emacs-shell-prompt][link]].

   Custom function to clear the shell in emacs. Bound to f8. Also
   works for gdb.

   Always use bash as the backend for the shell as not every machine
   has zsh.

   #+begin_src emacs-lisp
     (use-package shell
       :bind ("<f8>" . clear-shell)
       :init
       (setenv "ESHELL" "bash")
       :config
       ;; Use the prompts colours instead of ansi-color
       (set-face-attribute 'comint-highlight-prompt nil
                           :inherit nil)
       (add-hook 'shell-mode-hook
                 (lambda ()
                   ;; Enable color in shell
                   (ansi-color-for-comint-mode-on)
                   ;; Change Color theme in shell
                   (setq ansi-color-names-vector
                         ["#4d4d4d"
                          "#D81860"
                          "#60FF60"
                          "#f9fd75"
                          "#4695c8"
                          "#a78edb"
                          "#43afce"
                          "#f3ebe2"])
                   (setq ansi-color-map (ansi-color-make-color-map))
                   ;; Disable yas minor mode
                   (yas-minor-mode -1)
                   ;; Add go and goc to the dirtrack, Need tweak the regexp
                   ;; (setq shell-cd-regexp "\\(cd\\|goc\\|go\\)")
                   ))
       ;; Easier keybinding for jumping between prompts
       (add-hook 'shell-mode-hook
                 (lambda ()
                   (define-key comint-mode-map (kbd "C-M-p") 'comint-previous-prompt)
                   (define-key comint-mode-map (kbd "C-M-n") 'comint-next-prompt)))
       (defun clear-shell ()
         "Clear the shell buffer"
         (interactive)
         (let ((comint-buffer-maximum-size 0))
           (comint-truncate-buffer))))
   #+end_src
** guix
   #+begin_src emacs-lisp
     (when dotemacs-guix-installed
       (use-package guix
         :ensure nil
         :bind ("<f3>" . guix)
         :pin melpa-stable))
   #+end_src
* Custom
** Group
   Create a group to easier keep track of custom variables.
   #+begin_src emacs-lisp
     (defgroup plattfot nil
       "Gather my custom variables in one interface."
       :prefix "plt/")
   #+end_src

   #+begin_src emacs-lisp
     (defcustom plt/paper-directory "~/Downloads"
       "Directory where to store all technical papers."
       :group 'plattfot
       :type 'directory)

     (defcustom plt/paper-bibtex "~/Downloads/reference.bib"
       "Bibtex file associated with the technical papers."
       :group 'plattfot
       :type 'file)
   #+end_src
** Packages
*** home
    #+begin_src emacs-lisp
      (use-package home
        :ensure nil
        :load-path "plugins")
    #+end_src
*** bfuture
    #+begin_src emacs-lisp
      (use-package bfuture
        :ensure nil
        :load-path "bfuture.el")
    #+end_src
*** bank
    Functions for handling bank statements
    #+begin_src emacs-lisp
      (use-package bank
        :ensure nil
        :load-path "plugins")
    #+end_src
*** Multiple cursor extension
    Add some extra functionality to multiple cursors inserting numbers
    and characters.
    #+begin_src emacs-lisp
      (use-package mc-extra-extra
        :after (multiple-cursors)
        :ensure nil
        :load-path "plugins")
    #+end_src
*** newfile
    Functions for setting up a newfile in c++. I.e create the license
    boilerplate, add the include guard, header for the author etc and
    namespaces based on directory structure.
    #+begin_src emacs-lisp
      (use-package newfile
        :ensure nil
        :load-path "plugins")
    #+end_src
*** cpreproc
    Functions to help with c/c++ development
    #+begin_src emacs-lisp
      (use-package cpreproc
        :ensure nil
        :load-path "plugins")
    #+end_src
*** training
    Functions for using ledger as a training log.
    #+begin_src emacs-lisp
      (use-package training
        :ensure nil
        :load-path "plugins")
    #+end_src
*** tile
    Functions for tiling window managers
    #+begin_src emacs-lisp
      (use-package tile
        :ensure nil
        :load-path "plugins")
    #+end_src
** Functions
*** Buffer
**** Rename current file or buffer
     Function for renaming buffer and file. [[http://www.stringify.com/2006/apr/24/rename/][Source]]
     #+begin_src emacs-lisp
      (defun rename-current-file-or-buffer ()
        "Rename current file and buffer, similar to save-as but removes
      the old file"
        (interactive)
        (if (not (buffer-file-name))
            (call-interactively 'rename-buffer)
          (let ((file (buffer-file-name)))
            (with-temp-buffer
              (set-buffer (dired-noselect file))
              (dired-do-rename)
              (kill-buffer nil))))
        nil)
     #+end_src
**** Revert all buffers
    To sync all open buffers with their respective files on disk.
    Based on [[https://www.emacswiki.org/emacs/RevertBuffer][link]] but skips buffers which file no longer exist.
    #+begin_src emacs-lisp
        (defun revert-all-buffers ()
            "Refreshes all open buffers from their respective files."
            (interactive)
            (dolist (buf (buffer-list))
              (with-current-buffer buf
                (when (and (buffer-file-name)
                           (not (buffer-modified-p))
                           (file-exists-p (buffer-file-name)))
                  (revert-buffer t t t) )))
            (message "Refreshed open files."))
    #+end_src
**** ibuffer filters
    Similar to projectile's ibuffer filter. Except this isn't locked
    to the project root.
    #+begin_src emacs-lisp
      (defun ibuffer-at-directory (dir)
        "Open an ibuffer with buffers containg files with matching prefix DIR."
        (interactive "DDirectory to filter on: ")
        (ibuffer t (format "*%s-buffers*" dir) (list (cons 'directory dir))))
    #+end_src

    List all buffers which file no longer exist.
    #+begin_src emacs-lisp
      (use-package ibuf-ext
        :ensure nil
        :after (ibuffer)
        :config
        (define-ibuffer-filter dangling-buffer
            "True if buffer is visiting a file but the file no longer exist."
          (:reader nil :description "dangling-buffer")
          (with-current-buffer buf
            (and (buffer-file-name)
                 (not (file-exists-p (buffer-file-name))))))
        (defun ibuffer-dangling-buffers ()
          (interactive)
          "Open an ibuffer with buffers which file no longer exist."

          (ibuffer t "*dangling-buffers*" (list (cons 'dangling-buffer "")))))
    #+end_src
*** Text
    #+begin_src emacs-lisp
      (defun duplicate-line()
        "Clone line and paste it below."
        (interactive)
        (let ((line (buffer-substring (point-at-bol) (point-at-eol)))
              (current (point)))
          (goto-char (point-at-eol))
          (insert "\n" line)
          (goto-char current)))
    #+end_src

    Copy lines matching a regex to a separate buffer
    #+begin_src emacs-lisp
      ;; From
      ;; http://stackoverflow.com/questions/2289883/emacs-copy-matching-lines
      ;; by Trey Jackson
      (defun copy-lines-matching-re (re)
        "find all lines matching the regexp RE in the current buffer
      putting the matching lines in a buffer named *matching*"
        (interactive "sRegexp to match: ")
        (let ((result-buffer (get-buffer-create "*matching*")))
          (with-current-buffer result-buffer
            (erase-buffer))
          (save-match-data
            (save-excursion
              (goto-char (point-min))
              (while (re-search-forward re nil t)
                (princ (buffer-substring-no-properties (line-beginning-position)
                                                       (line-beginning-position 2))
                       result-buffer))))
          (pop-to-buffer result-buffer)))
    #+end_src

**** Format

     Different functions to quickly format text.
     #+begin_src emacs-lisp
       (defun fmt-parens-loosen (start end)
         "Add a space between parens and content for the region START END.

       e.g. (foo) -> ( foo ).

       It will not expand () by default. Use prefix to include it.

       When using this interactive it will pick the region from current
       point to the end of the buffer. If a region is active it will
       pick that instead."

         (interactive (if (use-region-p)
                          (list (region-beginning) (region-end))
                        (list (point) (point-max))))
         (let ((regexp
                (if (not current-prefix-arg)
                    ;; Ignore ()
                    "\\(?:\\(?1:(\\)\\(?2:[^ \n)]\\)\\|\\(?1:[^ (]\\)\\(?2:)\\)\\)"
                  ;; Include ()
                  "\\(?:\\(?1:(\\)\\(?2:[^ \n]\\)\\|\\(?1:[^ ]\\)\\(?2:)\\)\\)")))
           (fmt-replace-regexp regexp "\\1 \\2" start end)))
     #+end_src

     #+begin_src emacs-lisp
       (defun fmt-parens-tighten (start end)
         "Remove spaces between parens and content inside START and END.

       e.g. (  foo ) -> (foo)

       When using this interactive it will pick the region from current
       point to the end of the buffer. If a region is active it will
       pick that instead."
         (interactive (if (use-region-p)
                   (list (region-beginning) (region-end))
                 (list (point) (point-max))))
         (let ((regex "\\(?:\\(?1:(\\)[ ]+\\(?2:[^ ]\\)\\|\\(?1:[^ ]\\)[ ]+\\(?2:)\\)\\)"))
           (fmt-replace-regexp regex "\\1\\2" start end)))
     #+end_src

     #+begin_src emacs-lisp
       (defun fmt-one-space-after-comma (start end)
         "Make sure there is just one space after comma inside START and END.

       e.g. foo(bar,baz,  boo) -> foo(bar, baz, boo).

       When using this interactive it will pick the region from current
       point to the end of the buffer. If a region is active it will
       pick that instead."
         (interactive (if (use-region-p)
                   (list (region-beginning) (region-end))
                 (list (point) (point-max))))
         (my-replace-regexp "\\(?:\\(?1:,\\)[ ]*\\(?2:[^ \n]\\)\\)" "\\1 \\2" start end))
     #+end_src

     #+begin_src emacs-lisp
       (defun fmt-replace-regexp (regexp to-string start end)
         "Replace everything matching REGEXP with TO-STRING from START to END.

       This is similar to `replace-regexp' but using `re-search-forward'
       and `replace-match'."
         (save-excursion
           (goto-char start)
           (while (re-search-forward regexp end t)
             (let ((current-point (point)))
               (replace-match to-string)
               ;; The end point will shift when replacing text in the buffer
               (setq end (+ end (- (point) current-point)))))))
     #+end_src
*** Programming
**** C++
***** Expands a define macro for all matches in current buffer.
      #+begin_src emacs-lisp
        (defun replace-define()
          "Evaluating the define variable.
        Place cursor on a #define <var> <content> and execute this command and it will
        replace all <var> with <content> in the file."
          (interactive)
          (let ((line (split-string (thing-at-point 'line) )))
                 (if (equal (car line) "#define")
                     (let ((curr-pos (point)) ;; save current position
                           (end (point-max)))
                  ;; Jump to the end of line
                  (end-of-line)
                  ;; Replace the first with the second.
                  (while (re-search-forward (concat "\\_<"(nth 1 line)"\\_>") end t )
                         (replace-match (nth 2 line)))
                  ;; return to the same position
                  (goto-char curr-pos)
                  ;; move to the end of the line to indicate that it's done.
                  (end-of-line))
                   (message "Not a #define directive!" ))))
      #+end_src
***** Undo replace-define.
       #+begin_src emacs-lisp
         (defun replace-define-undo()
           "Undoing the expansion of the define variable.
         Place cursor on a #define <var> <content> and execute this
          command and it will replace all <content> with <var> in the
          file."

           (interactive)
           (let ((line (split-string (thing-at-point 'line) )))
             (if (equal (car line) "#define")
                 (let ((curr-pos (point)) ;; save current position
                       (end (point-max)))
                   ;; Jump to the end of line
                   (end-of-line)

                   ;; Replace the second with the first
                   (while (re-search-forward (nth 2 line) end t ) (replace-match (nth 1 line)))

                   ;; return to the same position
                   (goto-char curr-pos)
                   ;; move to the end of the line to indicate that it's done.
                   (end-of-line))
               (message "Not a #define directive!" ))))

       	   #+end_src

***** Convert typedef to c++11's alias
       #+begin_src emacs-lisp
         (defun convert-typedef-to-using ()
           "Converts typedef statements to using statements"
           (interactive)
           (let ((begin) (end))
              (if (use-region-p)
                 (progn (setq begin (region-beginning) end (region-end)))
               (progn (setq begin (point) end nil)))
              (goto-char begin)
             (while (re-search-forward
                     (concat "typedef \\(\\(?:typename \\)*"
                             "[[:print:]]+?\\)[ \t]+\\([[:alnum:]_]+\\)[ ]*;" )
                     end t )
               (replace-match "using \\2 = \\1;"))))
       #+end_src
***** Insert ifdef clauses

      #+begin_src emacs-lisp
        (defun afs-insert-ifdef (macro &optional add-else ifndef)
          "Insert C preprocessor conditional #ifdef MACRO. To add an else
          clause set ADD-ELSE to t. To invert the ifdef to #ifndef MACRO
           set ifndef to t."
          (interactive "sName of macro: ")
          (let* ((start (if (use-region-p) (region-beginning) (point-at-bol)))
                 (end (if (use-region-p) (region-end) (point-at-eol)))
                 (text (delete-and-extract-region start end))
                 (defcmd (if ifndef "#ifndef" "#ifdef")))
            (insert (concat (format "%s %s\n%s\n" defcmd macro text)
                            (when add-else (format "#else\n%s\n" text))
                            "#endif"))
            ))
      #+end_src

      #+begin_src emacs-lisp
        (defun afs-insert-ifdef-else (macro)
          "Insert C prepocessor conditional #ifdef MACRO with an else clause.
        Wrapper for (afs-insert-ifdef MACRO t)"
          (interactive "sName of macro: ")
          (afs-insert-ifdef macro t))
      #+end_src

      #+begin_src emacs-lisp
        (defun afs-insert-ifndef (macro)
          "Insert C prepocessor conditional #ifndef MACRO."
          (interactive "sName of macro: ")
          (afs-insert-ifdef macro nil t))
      #+end_src

      #+begin_src emacs-lisp
        (defun afs-insert-ifndef-else (macro)
          "Insert C prepocessor conditional #ifndef MACRO."
          (interactive "sName of macro: ")
          (afs-insert-ifdef macro t t))
      #+end_src

***** Convert java style comment to doxygen
     #+begin_src emacs-lisp
       (defun convert-java-comment-to-doxygen ()
           "Convert java style comment to doxygen"
         (interactive)
         (let ((begin) (end))
           (if (use-region-p)
               (progn (setq begin (region-beginning) end (region-end)))
             (progn (setq begin (point) end nil)))
           (goto-char begin)
           (while (re-search-forward
                   "/\\*\\*\n[ ]+\\*\\(.*\\)\n[ ]+\\*/"
                   end t )
             (replace-match "///\\1"))))

     #+end_src
***** Jump between template header and implementation
      #+begin_src emacs-lisp
        (defun ff-extension-other-impl ()
          "Return name of the header or template file corresponding to the current file."
          (interactive)
          (let* ((pathname (or (ff-buffer-file-name) "/none.none"))
                 (directory (file-name-directory pathname))
                 (filename (file-name-nondirectory pathname))
                 (ext (s-replace "c" "h" (file-name-extension filename)))
                 (base (file-name-base filename)))
            (ff-get-file `(,directory)
                         (format "%s.%s"
                                 (if (s-ends-with? "-impl" base)
                                     (s-chop-suffix "-impl" base)
                                   (s-append "-impl" base))
                                 ext))))
      #+end_src

*** Split lines
    Function for splitting lines at specified character. Default is ','.
    #+begin_src emacs-lisp
      (defun split-at (&optional delim)
      "Split region/line at DELIM, if there are multiple matches it
      will split each one. DELIM will default to \",\" if no delim is
      given."
      (interactive "sSpecify delimiter: ")
      (save-mark-and-excursion
        (when (or (string= delim "") (not delim)) (setq delim ","))
        (let ((start (if (use-region-p) (region-beginning) (point-at-bol)))
              (end (if (use-region-p) (region-end) (point-at-eol)))
              (regex delim))
          (goto-char start)
          (while (search-forward-regexp regex end t)
            (insert "\n")
            (setq end (1+ end)))
          (indent-region start end)
          (goto-char start))))

      (defun split-at-comma ()
      "wrapper for split-at for use with key command"
      (interactive)
      (split-at ","))
    #+end_src
*** Yesterday-time
    Computes the time 24 hours ago
    #+begin_src emacs-lisp
      (defun yesterday-time ()
      "Provide the date/time 24 hours before the time now in the format
      of `current-time'."
        (let* ((now-time (current-time))              ; get the time now
               (hi (car now-time))                    ; save off the high word
               (lo (car (cdr now-time)))              ; save off the low word
               (msecs (nth 2 now-time)))              ; save off the milliseconds

          (if (< lo 20864)                        ; if the low word is too small for subtracting
              (setq hi (- hi 2)  lo (+ lo 44672)) ; take 2 from the high word and add to the low
            (setq hi (- hi 1) lo (- lo 20864)))   ; else, add 86400 seconds (in two parts)

          (list hi lo msecs))) ; regurgitate the new values
    #+end_src
*** Org
**** Vinyl
     Extract info from my vinyl org table. The heading for each table is:
     | Artist | Album | Färg | Signerad | Inkl CD | Skivbolag | Typ | Skivor | Övrigt |

     #+begin_src emacs-lisp
       (cl-defstruct plt/vinyl
         "Struct for vinyl entries"
         (artist nil :type string)
         (album nil :type string)
         (color nil :type string)
         (signed nil :type boolean)
         (cd nil :type boolean)
         (label nil :type string)
         (type nil :type string)
         (discs nil :type integer)
         (misc nil :type string))

       (defun plt/vinyl-table-extraction ()
         "Extract a list of `plt/vinyl' for each line in the table."
         (let ((vinyls '())
               (region-begin (if (region-active-p) (region-beginning) (point-min)))
               (region-end (if (region-active-p) (region-end) (point-max))))
           (save-mark-and-excursion
             (goto-char region-begin)
             (while (< (point) region-end)
               (let ((vinyl (make-plt/vinyl))
                     (read-field-and-goto-next (lambda ()
                                                 (org-table-next-field)
                                                 (string-trim (org-table-get-field)))))
                 (setf (plt/vinyl-artist vinyl) (funcall read-field-and-goto-next))
                 (setf (plt/vinyl-album vinyl) (funcall read-field-and-goto-next))
                 (setf (plt/vinyl-color vinyl) (funcall read-field-and-goto-next))
                 (setf (plt/vinyl-signed vinyl) (if (string= (downcase (funcall read-field-and-goto-next)) "ja")
                                                    t nil))
                 (setf (plt/vinyl-cd vinyl) (if (string= (downcase (funcall read-field-and-goto-next)) "ja")
                                                t nil))
                 (setf (plt/vinyl-label vinyl) (funcall read-field-and-goto-next))
                 (setf (plt/vinyl-type vinyl) (funcall read-field-and-goto-next))
                 (setf (plt/vinyl-discs vinyl) (string-to-number (funcall read-field-and-goto-next)))
                 (setf (plt/vinyl-misc vinyl) (funcall read-field-and-goto-next))
                 (push vinyl vinyls))))
           vinyls))

       (defun plt/vinyl-table-to-roam ()
         "Prep vinyl tables to roam entries."
         (interactive)
         (with-output-to-temp-buffer
           "*Vinyl albums*"
           (--each (plt/vinyl-table-extraction)
             (princ (format "\
       ,#+title: %s
       ,#+roam_tags: \"album\"

       ,* Vinyl
         - Artist: %s
         - Färg: %s
         - Signerad: %s
         - Inkl CD: %s
         - Skivbolag: %s
         - Typ: %s
         - Skivor: %s
         - Övrigt: %s

       " (plt/vinyl-album it)
       (plt/vinyl-artist it)
       (plt/vinyl-color it)
       (if (plt/vinyl-signed it) "Ja" "Nej")
       (if (plt/vinyl-cd it) "Ja" "Nej")
       (plt/vinyl-label it)
       (plt/vinyl-type it)
       (plt/vinyl-discs it)
       (plt/vinyl-misc it))))))

     #+end_src
**** KOReader
     #+begin_src emacs-lisp
       (cl-defstruct (plt/koreader-note (:constructor plt/make-koreader-note))
         "Struct containing one note exported from KOReader"
         (text nil :type string)
         (sort nil :type string)
         (page nil :type integer)
         (time nil :type time)
         (chapter nil :type string))

       (defun plt/koreader-parse-clipping (clipping)
         "Parse CLIPPING and return the result.

       CLIPPING is a json file export from KOReader.

       The result will be a list which the first element will be the
       title followed by the notes for that title."
         (let* ((json (json-read-file clipping))
                (notes
                 (->> json
                      (--filter
                       (->> it
                            car
                            symbol-name
                            (s-matches? "[[:digit:]]+")))
                      (--map
                       (seq-map (lambda (note)
                                  (when-let* ((text (assq 'text note)))
                                    (plt/make-koreader-note
                                     :text (cdr text)
                                     :sort (cdr (assq 'sort note))
                                     :page (cdr (assq 'page note))
                                     :time (cdr (assq 'time note))
                                     :chapter (cdr (assq 'chapter note)))))
                                (cdr it)))
                      (-flatten)
                      (-non-nil)
                      )))
           `(,(cdr (assq `title json)) ,@notes)))

       (defun plt/koreader-clipping-to-org-notes (clipping)
         "Read CLIPPING to org notes.

       Where CLIPPING is a json export from KOReader."
         (interactive (list (read-file-name "KOReader json: ")))
         (let* ((notes (cdr (plt/koreader-parse-clipping clipping))))
           (with-output-to-temp-buffer "*KOReader notes*"
             (--each (-group-by 'plt/koreader-note-chapter notes)
               (princ (format "* %s\n" (car it)))
               (--each (cdr it)
                 (princ (format "** %s\n" (plt/koreader-note-text it)))
                 (princ (format "  :PROPERTIES:\n"))
                 (princ (format "  :PAGE: %s\n" (plt/koreader-note-page it)))
                 (princ (format "  :END:\n"))
                 (princ (format-time-string "   <%Y-%m-%d %a %H:%M:%S>\n" (plt/koreader-note-time it))))))))
     #+end_src
** Keybindings
*** Minor mode
   To better organize what my custom keys are and also easy see what
   they do. I wrapped them up into a minor mode. Can just run
   'describe-minor-mode' then plattfot-mode to get a quick list of
   them. Downside is that I lost a bit of structure in this file when
   reading.

   Time will tell if that was a smart idea or not.

   #+begin_src emacs-lisp
     (defun plt/insert-non-breaking-space ()
       "Insert a non-breaking space:  ."
       (interactive)
       (insert " "))

     (defun plt/scroll-up-command-10 ()
       "Scroll up buffer 10 lines."
       (interactive)
       (scroll-up-command 10))

     (defun plt/scroll-down-command-10 ()
       "Scroll down buffer 10 lines."
       (interactive)
       (scroll-down-command 10))

     (defvar plattfot-mode-map
       (let ((map (make-sparse-keymap)))
         ;; Navigation
         (define-key map (kbd "C-x f") 'find-file-at-point)
         ;; Text search
         ;; Rebinding the text search to the regex variants as
         ;; use those far more than the normal ones.
         (define-key map (kbd "C-s") 'isearch-forward-regexp)
         (define-key map (kbd "C-r") 'isearch-backward-regexp)
         (define-key map (kbd "C-S-s") 'isearch-forward-symbol-at-point)
         ;; Text edit
         (define-key map (kbd "M-SPC") 'plt/insert-non-breaking-space)
         (define-key map (kbd "M-r") 'replace-regexp)
         (define-key map (kbd "C-c l") 'duplicate-line)
         (define-key map (kbd "C-c ,") 'split-at-comma)
         ;; Buffer functions
         (define-key map (kbd "C-c <f5>") 'revert-all-buffers)
         (define-key map (kbd "C-c R") 'rename-current-file-or-buffer)
         (define-key map (kbd "<f5>") 'revert-buffer)
         ;; Compile from current location and to re-run
         (define-key map (kbd "<f12>") 'compile)
         (define-key map (kbd "<f11>") 'recompile)

         ;; Scrolling
         (define-key map (kbd "<next>") 'plt/scroll-up-command-10)
         (define-key map (kbd "<prior>") 'plt/scroll-down-command-10)
         ;; Slow scrolling
         (define-key map (kbd "<C-next>") 'scroll-up-line)
         (define-key map (kbd "<C-prior>") 'scroll-down-line)
         ;; Jump almost the whole page
         (define-key map (kbd "<M-next>") 'scroll-up-command)
         (define-key map (kbd "<M-prior>") 'scroll-down-command)

         (define-key map (kbd "<C-M-next>") 'end-of-buffer)
         (define-key map (kbd "<C-M-prior>") 'beginning-of-buffer)

         (define-key map (kbd "<f2>") 'home-setup)
         (define-key map (kbd "<f3>") 'work-setup)
         map)
       "Custom keymap for `plattfot-mode'.")

     (defvar plattfot-comint-mode-map
       (let ((map (copy-keymap plattfot-mode-map)))
         ;; Avoid overloading M-r in comint mode as that is used for
         ;; fetching history.
         (define-key map (kbd "M-r") 'consult-history)
         map)
       "Custom keymap for `plattfot-comint-mode'.")

     (define-minor-mode plattfot-mode
       "Custom keybindings for plattfot:
          \\{plattfot-mode-map}"
       :version "3.0.0"
       :lighter nil
       :keymap plattfot-mode-map
       nil)

     (define-globalized-minor-mode plattfot-global-mode plattfot-mode
       (lambda () (plattfot-mode 1)))

     (define-minor-mode plattfot-comint-mode
       "Custom keybindings for plattfot that removes the replace-regex keybinding:
          \\{plattfot-comint-mode-map}"
       :version "3.0.0"
       :lighter nil
       :keymap plattfot-comint-mode-map
       nil)

     (provide 'plattfot)
   #+end_src

   Added that I need to press ctrl and the function key for the UI keys
   as I was hitting these accidentaly from time to time when running
   'compile' or 'recompile'. Due to how my keyboard is layed out. See
   my [[https://github.com/plattfot/qmk_firmware/tree/master/layouts/community/ergodox/plattfot][qmk fork]] for why that is.

   Reason for having three different modes is to be able to disable
   the 'M-r' keybinding for comint modes, eg. shell and gud-gdb. This
   was the cleanest way I could find doing this.

   #+begin_src emacs-lisp
     (use-package plattfot
       :init
       (plattfot-global-mode 1)
       ;; Change to the comint mode to get history search.
       (add-hook 'comint-mode-hook
                 (lambda ()
                   (plattfot-mode 0)
                   (plattfot-comint-mode 1)))
       (add-hook 'eshell-mode-hook
                 (lambda ()
                   (plattfot-mode 0)
                   (plattfot-comint-mode 1)))
       :ensure nil)
   #+end_src

*** Macros
     "Macro" to quickly open a file that is located on my machine at
     work. As I'm just inserting text I switched the real macro to just
     using insert instead.

     Updated it only bind the key when I'm in the minibuffer as I
     don't have any use for this outside of that scope.
     #+begin_src emacs-lisp
       (add-hook
        'minibuffer-setup-hook
        (lambda ()
          (define-key minibuffer-local-map (kbd "C-c B")
            (lambda ()
              (interactive)
              (insert "/-:pd-ws-he03.d2.com:/dd/dept/software/users/fredriks/swdevl")))))
     #+end_src
*** Registers
    Quickly jump to files by pressing C-x r j <register>
    Jump to my init file with 'e' and init directory with 'i'.
    #+begin_src emacs-lisp
      (set-register ?e (cons 'file (concat user-emacs-directory "init.el")))
      (set-register ?i (cons 'file (concat user-emacs-directory
                                           "init.d/configuration.org")))
    #+end_src
* Work
** Custom
*** Packages
**** dd-newfile
     Function that inserts the DD template for a new file
     #+begin_src emacs-lisp
       (use-package dd-newfile
         :after newfile
         :ensure nil
         :load-path "plugins")
     #+end_src
**** dd-log-parser
     Functions for parsing the =DD::Logger=
     #+begin_src emacs-lisp
       (use-package dd-log-parser
         :if dotemacs-is-work
         :ensure nil
         :load-path "plugins")
     #+end_src
**** dd-pybuild2
     #+begin_src emacs-lisp
       (use-package dd-pybuild2
         :if dotemacs-is-work
         :ensure nil
         :load-path "plugins")
     #+end_src
**** houdini
     Houdini related functions, mostly handle houdini versions.
     #+begin_src emacs-lisp
       (use-package houdini
         :bind ("C-x j" . hou-insert-version)
         :if dotemacs-is-work
         :ensure nil
         :load-path "plugins")
     #+end_src
**** highlight-extra
     Functions for highlighting my shells when building etc
     #+begin_src emacs-lisp
       (use-package highlight-extra
         :ensure nil
         :load-path "plugins")
     #+end_src
**** work

     Bunch of functions to setup my work area when at work.
     #+begin_src emacs-lisp
       (use-package work
         :if dotemacs-is-work
         :ensure nil
         :load-path "plugins")
     #+end_src
*** Functions
**** PID
     Functions for getting the pid and other useful stuff regarding
     PIDs.

     #+begin_src emacs-lisp
       (cl-defstruct plt/ps
         "Struct that contains the output from `ps-match'."
         (pid nil :documentation "Process ID" :type 'integer)
         (time nil :documentation "Time when the process was started" :type 'time)
         (ppid nil :documentation "Parent Process ID" :type 'integer)
         (user nil :documentation "User that started the process" :type 'string)
         (comm nil :documentation "The command that launched the process" :type 'string)
         (cmd nil :documentation "The command and all its args" :type string))
     #+end_src

     #+begin_src emacs-lisp
       (defun pid (ps-list &optional index newest)
         "Get the pid of the command in PS-LIST at the position specified by INDEX.

       If INDEX is not specified it will pick the first command in PS-LIST.

       If NEWEST is t, it will sort the commands based on elapsed time
       before picking one."
         (interactive)
         (plt/ps-pid (nth (or index 0) (if newest (sort-ps-time ps-list) ps-list))))
     #+end_src

     #+begin_src emacs-lisp
       (defun ps-match (regex)
         "Return a list of `plt/ps' which command matches REGEX.
       This is simplified version of `list-system-processes' and
       `process-attributes' but works with tramp.

       Requires the commandline tools ps and awk to be available."
         (let ((ps-list
                (mapcar
                 'split-string
                 (split-string
                  (shell-command-to-string
                   (format "ps axo lstart,pid,ppid,user,comm,cmd | awk '$9 ~ /%s/'" regex))
                  "\n" t))))
           (mapcar
            (lambda (x)
              (let ((proc (nthcdr 5 x))
                    (time (date-to-time (string-join (butlast x 4) " "))))
                (make-plt/ps :pid (string-to-number (car proc))
                             :time time
                             :ppid (string-to-number (nth 1 proc))
                             :user (nth 2 proc)
                             :comm (nth 3 proc)
                             :cmd (string-join (nthcdr 4 proc) " "))))
            ps-list)))
     #+end_src

     #+begin_src emacs-lisp
       (defun sort-ps-time (ps-list)
         "Sort the PS-LIST based on the timestamp.
       In ascending order."
         (seq-sort (lambda (a b) (not (time-less-p (plt/ps-time a) (plt/ps-time b)))) ps-list))
     #+end_src

     #+begin_src emacs-lisp
       (defun attach-pid (ps-list &optional index newest)
         "Prints 'attach <pid>' into the buffer.
       Where PS-LIST is a list of `plt/ps'

       INDEX is use to select which one if there are multiple instances
       running, INDEX counts from 1. If not set it will pick the first
       instance.

       If NEWEST is set to t, it will sort the list based on start time
       before selecting."
         (interactive "p")

         ;; The default for index is one.
         (when (not index) (setq index 1))
         (when (< index 1) (setq index 1))
         (if ps-list
             (insert (format "attach %s" (pid ps-list (- index 1) newest)))
           (message "The process list is empty")))
     #+end_src
**** PID Houdini
     Get a list of PID for houdini processes
     #+begin_src emacs-lisp
       (defun ps-houdini ()
         "Get a list of `plt/ps' for running houdini processes."
         (ps-match "houdini-bin"))
     #+end_src

     Get a list of PID for houdini core processes
     #+begin_src emacs-lisp
       (defun ps-houdinicore ()
         "Get a list of `plt/ps' for running houdini processes."
         (ps-match "houdinicore-bin"))
     #+end_src

     Get a list of PID for houdini fx processes
     #+begin_src emacs-lisp
       (defun ps-houdinifx ()
         "Get a list of `plt/ps' for running houdini processes."
         (ps-match "houdinifx-bin"))
     #+end_src

**** PID Maya
     Get a list of PID for maya processes
     #+begin_src emacs-lisp
       (defun ps-maya ()
         "Get a list of `plt/ps' for running maya processes."
         (ps-match "maya\\.bin"))
     #+end_src
**** Attach Houdini
     Used with gdb, prints attach <pid of houdini> in the prompt.
     #+begin_src emacs-lisp
       (defun attach-houdini (&optional index)
         "Prints attach <pid> into the buffer.
       INDEX is the same as in `attach-pid'."
         (interactive"p")
         (attach-pid (ps-houdini) index))

       (defun attach-houdinicore (&optional index)
         "Prints attach <pid> into the buffer.
       INDEX is the same as in `attach-pid'."
         (interactive"p")
         (attach-pid (ps-houdinicore) index))

       (defun attach-houdinifx (&optional index)
         "Prints attach <pid> into the buffer.
       INDEX is the same as in `attach-pid'."
         (interactive"p")
         (attach-pid (ps-houdinifx) index))
     #+end_src

     #+begin_src emacs-lisp
       (defun attach-houdini-newest (&optional index)
         "Prints attach <pid> into the buffer.
       INDEX is the same as in `attach-pid'.

       PIDs are sorted on elapsed time before one is selected."
         (interactive"p")
         (attach-pid (ps-houdini) index t))

       (defun attach-houdinicore-newest (&optional index)
         "Prints attach <pid> into the buffer.
       INDEX is the same as in `attach-pid'.

       PIDs are sorted on elapsed time before one is selected."
         (interactive"p")
         (attach-pid (ps-houdinicore) index t))
     #+end_src
**** Attach Maya
     #+begin_src emacs-lisp
       (defun attach-maya (&optional index)
         "Prints attach <pid> into the buffer.
       INDEX is use to select which one if there are multiple instances
       running, INDEX counts from 1."
         (interactive"p")
         ;; The default for index is one.
         (when (< index 1) (setq index 1))
         (insert (concat "attach " (pid-maya index) )))
     #+end_src
**** Kill Houdini
     #+begin_src emacs-lisp
       (defun kill-houdini ()
         "Kill houdini.
       If more than one houdini are running it will kill the
       first one in the ps list."
         (interactive)
         (shell-command (concat "kill -9 " (pid (ps-houdini)))))
     #+end_src
**** Kill Maya
     #+begin_src emacs-lisp
       (defun kill-maya ()
         "Kill maya.
       If more than one Maya process are running it will kill the
       first one in the ps list."
         (interactive)
         (shell-command (concat "kill -9 " (pid (ps-maya)))))
     #+end_src
**** Preproccess
     #+begin_src emacs-lisp
       (defun preprocess-fix-macros ()
         "Fix expanded macros when running only the preprocess on a file.
       For example: g++ <flags> -E <file>.  Since they are expanded into
       a single line which makes them hard to debug."
         (interactive)
         (let* ((start (if (use-region-p) (region-beginning) (point)))
                (end (if (use-region-p) (region-end) (point-max)))
                (regex-map '(":[ ]" ";" "{" "}[ ]"))
                (regex (mapconcat (lambda (x) (format "\\(%s\\)" x)) regex-map "\\|")))
           (goto-char start)
           (while (search-forward-regexp regex end t)
             (newline)
             (setq end (1+ end)))
           (indent-region start (point))
           (goto-char start)))
     #+end_src
**** Make
***** Functions to speed up the port of old style Makefiles to using modules.
     #+begin_src emacs-lisp
       (defun make-boost-components ()
         "Convert old style boost libs to module style"
         (interactive)
         (let ((begin) (end))
           (if (use-region-p)
               (progn (setq begin (region-beginning) end (region-end)))
             (progn (setq begin (point-min) end nil)))
           (goto-char begin)
           (while (re-search-forward
                   (concat "\\$(\\(?:EXECS\\|LIBS\\))_LIBS \\+= "
                           "\\$(BOOST_LIB_DIR)/libboost_\\(.*?\\)\\.a") end t)
             (replace-match "BOOST_COMPONENTS += \\1"))))

       (defun make-include-to-modules ()
         "Convert old Makefile's INCLUDE to using modules"
         (interactive)
         (let ((begin) (end))
           (if (use-region-p)
               (progn (setq begin (region-beginning) end (region-end)))
             (progn (setq begin (point-min) end nil)))
           (goto-char begin)
           (while (re-search-forward
                   "INCLUDES \\+= \\$(\\(.*\\)_INC_DIR)" end t)
             (replace-match
              (concat "MODULES += " (downcase (match-string-no-properties 1))) t ))))

       (defun make-mkl-module ()
         "Convert old mkl static libs to using the mkl module's flags"
         (interactive)
         (let ((begin) (end))
           (if (use-region-p)
               (progn (setq begin (region-beginning) end (region-end)))
             (progn (setq begin (point-min) end nil)))
           (goto-char begin)
           (when (re-search-forward
                  (concat "\\$(\\(?:EXECS\\|LIBS\\))_LIBS \\+= "
                          "\\$(MKL_STATIC_LAYERED_LIBS)") end t)
             (replace-match "MKL_USE_STATIC_LIBS = YES"))))

       (defun make-eigen-module ()
         "Convert eigen cxxflag to using the eigen module's flags"
         (interactive)
         (let ((begin) (end))
           (if (use-region-p)
               (progn (setq begin (region-beginning) end (region-end)))
             (progn (setq begin (point-min) end nil)))
           (goto-char begin)
           (when (re-search-forward
                  "X?CXXFLAGS \\+= -DEIGEN_USE_MKL_ALL" end t)
             (replace-match "EIGEN_USE_MKL = YES"))))

       (defun make-openvdb-module ()
         "Convert openvdb cxxflag to using the openvdb module's flags"
         (interactive)
         (let ((begin) (end))
           (if (use-region-p)
               (progn (setq begin (region-beginning) end (region-end)))
             (progn (setq begin (point-min) end nil)))
           (goto-char begin)
           (when (re-search-forward
                  "X?CXXFLAGS \\+= -DOPENVDB_3_ABI_COMPATIBLE" end t)
             (replace-match "OPENVDB_USE_ABI_3 = YES"))))

       (defun make-insert-toolchain (&optional toolchain)
         "Insert TOOLCHAIN = TOOLCHAIN, where the last is the variable TOOLCHAIN."
         (interactive "sName of toolchain to use: ")

         (when (not toolchain) (setq toolchain "gcc") )

         (let ((begin) (end))
           (if (use-region-p)
               (progn (setq begin (region-beginning) end (region-end)))
             (progn (setq begin (point-min) end nil)))
           (goto-char begin)
           ;; Move to the end of the _SRCS
           (while (re-search-forward "\\$(\\(?:EXECS\\|LIBS\\))_SRCS \\+= .*" end t))

           (insert (concat "\n\nTOOLCHAIN = " toolchain))))

       (defun make-delete-libpaths-and-rpath ()
         "Delete LIBPATHS += and RPATH_LIBSPATHS from the makefile"
         (interactive)
         (let ((begin) (end))
           (if (use-region-p)
               (progn (setq begin (region-beginning) end (region-end)))
             (progn (setq begin (point-min) end (point-max))))
           (delete-matching-lines "\\(?:RPATH_\\)?LIBPATHS \\+= .*" begin end )))

       (defun make-delete-libs ()
         "Delete $(EXECS/LIBS)_LIBS += lines from the makefile"
         (interactive)
         (let ((begin) (end))
           (if (use-region-p)
               (progn (setq begin (region-beginning) end (region-end)))
             (progn (setq begin (point-min) end (point-max))))
           (delete-matching-lines "\\$(\\(?:EXECS\\|LIBS\\))_LIBS \\+= .*" begin end )))

       (defun convert-make-to-modules ()
         "Convert old makefile to using modules"
         (interactive)
         (make-insert-toolchain)
         (make-include-to-modules)
         (make-mkl-module)
         (make-eigen-module)
         (make-openvdb-module)
         (make-boost-components)
         (make-delete-libpaths-and-rpath)
         (make-delete-libs))
     #+end_src
*** Modes
**** Editing doc strings in the Make project

     Using #: to mark comments as docstrings for the parser. But
     they're a pain to format using fill-paragraph. Deriving a mode
     from makefile-gmake-mode that changes the comments to match these
     tags to easier editing. Note that it will not see # as comments
     anymore and will mess up the format for those, only use this mode
     when editing the docstrings.

     Another option would be to modify the `paragraph-start' regexp
     but it's a pain to get it right and you'll need to change the
     `fill-prefix' to make it work. Which messes up the the
     rest. Probably better when dealing with doxygen comments as this
     [[https://stackoverflow.com/q/1972219][stackoverflow question]] is wondering about.

     #+begin_src emacs-lisp
       (define-derived-mode makefile-bs-mode makefile-gmake-mode "BSmakefile"
         "An adapted `makefile-mode' that uses #: as comments."
         (setq-local comment-start "#:")
         (setq-local comment-end "")
         (setq-local comment-start-skip "#:+[ \t]*"))
     #+end_src

** Behaviour
   Store work related settings.
   #+begin_src emacs-lisp
     (let ((.work (concat user-emacs-directory ".work.el")))
       (when (file-exists-p .work)
         (load .work)))
   #+end_src
* Bug workarounds
  Workarounds for bugs I have encountered through out the years
** Cursor turns black
   Set the cursor color to white.
   #+begin_src emacs-lisp
     (set-cursor-color "#ffffff")
   #+end_src
** Maximize emacs under KDE
   Issue maximizing emacs with KDE at work
   #+begin_src emacs-lisp
     (setq frame-resize-pixelwise t)
   #+end_src
** Juniper VPN linux 4.5+
   Juniper VPN doesn't work in linux 4.5+, workaround is to disable
   the ipv6.
   #+begin_src sh :tangle no
   echo 1 > /proc/sys/net/ipv6/conf/all/disable_ipv6
   #+end_src
** Tramp hangs after password entry
   :PROPERTIES:
   :CUSTOM_ID:  tramp-hang-workaround
   :END:
   See [[https://www.emacswiki.org/emacs/TrampMode#toc7][EmacsWiki]]
   Simple fix if you don't want to use emacs shells is to add this to your .zshrc
   #+begin_src sh :tangle no
     [[ $TERM == "dumb" ]] && unsetopt zle && PS1='$ ' && return
   #+end_src

   Problem with this though it that it messes up with the prompt when
   running a emacs shell. For that use:
   #+begin_src sh :tangle no
     # Tramp and emacs shell workaround
     if [[ $TERM == "dumb" ]]
     then
         # Emacs shell/tramp cannot handle line editing, turning it off.
         unsetopt zle

         # The custom prompt will hang tramp.
         # Change to something simpler and stop
         if [[ $INSIDE_EMACS == '' ]]
         then
             PS1='$ '
             return
         fi
     fi
   #+end_src

   Similar issue will happen with a bash shell on the other end. And
   for that you can just remove the =unsetopt zle=.

   The [[https://www.gnu.org/software/emacs/manual/html_node/tramp/Remote-shell-setup.html][manual]] describe that you can customize the
   =tramp-shell-prompt-pattern= to match your remote prompt. Didn't
   not get that to work. Same with the =Interactive shell prompt= from
   what I can tell tramp doesn't set INSIDE_EMACS to contain tramp. So
   this is the only workaround I found that is working. I.e. tramp
   sets the terminal to dumb when testing a connection but it doesn't
   set INSIDE_EMACS. Those two are set when running a shell either
   locally or remote. When using a tramp connection it sets the
   HISTFILE to be a tramp file. That's the only way I found to
   distinguish between a shell that is running locally or from a tramp
   connection.
** Paragraph fill in empty message-mode buffer
   They changed the formating in emacs 26.1 so everything before
   --text follows this line--
   Is treated as a headline and the first line is indented with some spaces.

   #+begin_src text
     I am sorry about your difficulties with git push.  It is true that in this
         situation
     --text follows this line--
     I am sorry about your difficulties with git push.  It is true that in
     this situation
   #+end_src
   [[https://emacs.stackexchange.com/a/41803][source]]

   Workaround is just to add
   #+begin_src test
   --text follows this line--
   #+end_src
** Alternative commands when magit is used on a slow host/connection
*** view commits not pushed to upstream branch of master

    This is similar to what magit recent commits show.
    #+begin_src shell
      git log master@{u}^.. --oneline
    #+end_src

    For quick access alias it to =git ahead=
    #+begin_src shell
      git config --global alias.ahead 'log master@{u}^.. --oneline'
    #+end_src

* Notes
** Emacs
*** Lisp in search replace
    To execute a lisp function in replace regexp do \,(<function>)
*** Org
**** Skip code block
     You can use =:tangle no= in the =SRC_BLOCK= to ignore the code
     block from being exported aka tangled. Good for example blocks that
     you don't want to end up in you config file.
**** Create block shortcut
     Create source block type "<s" on a new line and press <tab>
*** Flycheck
**** Tweak flycheck
    To set specific compiler and flags for a specific project you can
    use something like this in a .dir-locals.el file:
    #+begin_src emacs-lisp :tangle no
      ;; File .dir-locals.el
      ( ( c++-mode
          . ((flycheck-c/c++-gcc-executable . "/tools/package/gcc/6.4.0/bin/g++" )
             (flycheck-gcc-language-standard . "c++14")
             (flycheck-gcc-include-path
              . ("/dd/dept/software/users/fredriks/swdevl/corelibs/PRIVATE/include") )
             (flycheck-gcc-includes . ("openvdb/math/Vec3.h"))
             (flycheck-gcc-warnings . ("all"))
             (flycheck-gcc-definitions
              . ("_GLIBCXX_USE_CXX11_ABI=0"
                 "EIGEN_MATRIXBASE_PLUGIN=<DD/Utility/EigenMatrixBaseAddon.hpp>"
                 "DD_OPEN_MESH_POLYMESHT_EXTENSION=<DD/Math/Geometry/OpenMesh/OpenMesh_PolyMeshT_Extension.hpp>"
                 "DD_OPEN_MESH_TRIMESHT_EXTENSION=<DD/Math/Geometry/OpenMesh/OpenMesh_TriMeshT_Extension.hpp>"
                 "DD_CORELIBS_USE_OPENMESH"
                 "DD_CORELIBS_BUILD_LIBS"
                 "EIGEN_MATRIXBASE_PLUGIN=<DD/Utility/EigenMatrixBaseAddon.hpp>"
                 "EIGEN_MATRIX_PLUGIN=<DD/Utility/EigenMatrixAddon.hpp>"
                 ))
             (flycheck-gcc-args
              . ("-B/tools/package/binutils/2.29.1/bin"
                 "-isystem/tools/package/openvdb/4.0.1_dd01/include"
                 "-isystem/tools/package/eigen/3.3.4/include/eigen3"
                 "-isystem/tools/package/embree/2.15.1_gcc4.8/include"
                 "-isystem/tools/package/gtest/1.8.0/include"
                 "-isystem/tools/package/openmesh/6.3/include"
                 "-isystem/tools/package/tbb/4.4.6/include"
                 "-isystem/tools/package/boost/1.61.0/include"
                 "-isystem/tools/package/blosc/1.5.0/include"
                 "-isystem/tools/package/ilmbase/2.2.0/include/Ilmbase"
                 "-isystem/tools/package/ilmbase/2.2.0/include"
                 "-isystem/tools/package/ilmbase/2.2.0/include/OpenEXR"
                 "-isystem/tools/package/corelog/3.0.2/include"
                 "-isystem/tools/package/qhull/2012.1/include"
                 "-isystem/tools/include"
                 )))))
    #+end_src
    For clang just replace gcc with clang.

    If you want to play it more safe you can use the flychecks other
    variables (see C-c ! ?). Note that flycheck-include-path just
    prepend -I for all strings in the list. So for third party libs
    it's better to use -isystem.

    Also prefer flycheck-gcc-includes over adding that in
    flycheck-gcc-args as if you do
    #+begin_src emacs-lisp :tangle no
      (flycheck-gcc-args
       . ("-include openvdb/math/Vec3.h")
      )
    #+end_src
    You'll get an error about cannot find file, even though the file
    actually exist. That's because the thing that parses this and
    passes it to a shell escapes the whitespace after -include. So for
    that to work you'll need to do:

    #+begin_src emacs-lisp :tangle no
      (flycheck-gcc-args
       . ("-includeopenvdb/math/Vec3.h")
      )
    #+end_src
    Which is not that readable.

**** Language standard in c++
    Specify language standard in dir locals file: .dir-locals.el
    For example
    ((c++-mode
      (flycheck-clang-language-standard . "c++14")
      (flycheck-gcc-language-standard . "c++14")))
*** Elisp
**** Elisp Regex
     Link to elisp regular expression
     https://www.gnu.org/software/emacs/manual/html_node/elisp/Regular-Expressions.html
**** Change font size on the fly
     Use commands
     C-x C-+ and C-x C--
**** Doc
     Use C-h f to get docs on function
*** Case-sensitive search
    press M-c after search
*** Remove/Keep lines matching regexp
    use 'keep-lines' to keep lines matching regexp.
    use 'flush-lines' to remove lines matching regexp.
*** See what font is used under cursor
    #+begin_src text :tangle no
      M-x describe-char
    #+end_src
    or
    #+begin_src text :tangle no
      C-u C-x =
    #+end_src
    [[https://stackoverflow.com/a/1242760][source]]
*** Don't truncate messages in *scratch*
    #+begin_src emacs-lisp :tangle no
      (setq eval-expression-print-length nil)
    #+end_src
    Default is 12.
*** Reload dir-locals for buffer
    #+begin_src emacs-lisp
      (hack-dir-local-variables-non-file-buffer)
    #+end_src
** VCS
*** Git
**** Change message in most recent commit
     git commit --amend [-m ""]
*** Subversion
**** Roll back a tag

     Check out the tags directory. Use --depth=empty to avoid
     populating all the tags as this can take a really long time
     depending on how many tags exist.
     #+begin_src sh :tangle no
       svn checkout SVN_URL/REPO/tags  --depth=empty REPO-tag-fix
     #+end_src

     Locate the revision to roll back to.
     #+begin_src sh :tangle no
       svn log SVN_URL/REPO/tags
     #+end_src

     Then cd into the working copy and update all tags involved in the
     roll back. Otherwise svn will just ignore the roll back.
     #+begin_src sh :tangle no
       cd REPO-tag-fix
       svn up --set-depth=infinity TAG0 TAG1...
     #+end_src

     Roll back to the revision you want by simply merging the tags
     directory backwards to that revision.
     #+begin_src sh :tangle no
       svn merge -rHEAD:REVISION .
     #+end_src

     Where REVISION is the revision number you picked previously. HEAD
     is a svn built in keyword and points to the latest revision.
** Code
*** Run functions when loading/unloading shared libraries
    Call function when shared library is loaded, with gcc use:
    #+begin_src c++
      __attribute__((constructor)) void func(){}
    #+end_src

    Call function when shared lbirary is unloaded, with gcc use:
    #+begin_src c++
      __attribute__((destructor)) void func(){}
    #+end_src
*** Check what indentation rule is used for c++
    Run the function ~c-show-syntactic-information~ normaly bound to.
    #+begin_src :tangle no
    C-c C-s
    #+end_src
    Useful when customizing a style.
*** python
**** Reload module from another path

     First modify the sys.path then call reload to update the
     module. If it's a submodule you're trying to update, update the
     main module first.

     This is useful when developing extensions for gdb and you want to
     replace an already installed and loaded extension with a developer
     version.

     #+begin_src python :tangle no
       import sys

       sys.path.insert(0, 'new/path/to/module')
       reload(module)
     #+end_src
**** Generate etags
     #+begin_src shell :tangle no
       find . -name "*.py" -print | etags -
     #+end_src

     To ignore a specific directory, for example =private= which
     contains build and install artifacts.

     #+begin_src shell :tangle no
       find . -type d -name private -prune -or -name "*.py" -print | etags -
     #+end_src
**** Set breakpoints when using pytest
     Place this in the code
     #+begin_src python :tangle no
        import pdb;pdb.set_trace()
     #+end_src
     Then (if using =python-3.7+= just call
     #+begin_src python :tangle no
       breakpoint()
     #+end_src
     where you want pytest to drop into pdb
     See [[https://docs.pytest.org/en/latest/usage.html#setting-breakpoints][setting-breakpoints]] in the docs for more info.
**** Print function name

     When a debugger is hard to setup and easiest is to just use plane
     old print statements. Printing out the function name is useful to
     know where the print statement is located.
     #+begin_src python
       import inspect

       print("{}: ".format(inspect.currentframe().f_code.co_name))
     #+end_src

     alternative =sys._getframe= can be used instead of =inspect.currentframe()=.
     [[https://stackoverflow.com/a/13514318][source]]

*** Print out debug info
    #+begin_src sh :tangle no
      readelf --debug-dump=<option> <elf>
    #+end_src

    Print out the decoded source path use the
    src_sh[:tangle no]{--debug-dump=decodedline} option.
** Cli
*** Install fonts local to user
    Install fonts to ~/.fonts then update the fontconfig cache by
    running.
    #+begin_src sh
      fc-cache -v ~/.fonts
    #+end_src
    The option '-v' is just for verbose output and can be skipped.

    To see what fonts are installed run
    #+begin_src sh
      fc-list
    #+end_src
*** Terminfo files (ti)
    To compile FILE run
    #+begin_src sh :tangle no
      tic FILE
    #+end_src
*** Shell
    Stop the shell from echoing the command.
    #+begin_src sh :tangle no
      stty -echo
    #+end_src
**** Shell script
***** Argument parsing
      A good way of parsing the arguments for a shell script is using
      getopt (enhanced). There's also built in shell command in bash
      called getopts. But that one doesn't handle long options.

      To use getopt in a script simply do:

      #+begin_src sh
         # Use getopt to parse the command-line arguments
         _args=$(getopt --options h --longoptions workspace:,update::,help -- "$@")
         if [[ $? != 0 ]]
         then
             echo "Try '$0 --help for more information.'" >&2
             exit $_error_input
         fi

         eval set -- "$_args"

         while [[ $# -gt 0 ]]; do
             case "$1" in
                 --workspace)
                     _workspace=$2
                     shift 2
                     ;;
                 --update)
                     _update_func=update
                     # Filters separated by comma
                     for arg in ${2//,/ }
                     do
                         _filter[$arg]=0
                     done
                     shift 2
                     ;;
                 -h|--help)
                     echo -e "${help}"
                     exit
                     ;;
                 --)
                     # End of command-line arguments
                     shift
                     break
                     ;;
             esac
         done
      #+end_src
** Programs
*** find
**** Ignore directories while searching
     For example while searching for file named foobar, ignore all .svn
     directories.
     #+begin_src sh
       find . -not \( -path '*/.svn' -prune \) -name "foobar"
     #+end_src
*** grep
    Print only the grouping of the regex that matched

    Can use perl's look around assertions. For example only print out
    the ticket number of a tool that outputs
    #+begin_src text :tangle no
    Ticket created: 145704
    #+end_src

    #+begin_src shell :tangle no
    tool | grep -Po "Ticket created: \K145704"
    #+end_src
    [[https://unix.stackexchange.com/a/13472][source]]
*** ssh
**** ssh agent
     Use the ssh agent to cache the private key to a terminal
     #+begin_src sh
       eval $(ssh-agent)
       ssh-add ~/.ssh/private-key
     #+end_src
**** multihop with same key
     Use an intermediate machine (=JUMPHOST=) to ssh to the remote
     host (=REALHOST=) without needing to generate a key on the
     =JUMPHOST=.
     #+begin_src sh
     ssh -A -t -l USER1 JUMPHOST ssh -A -t -l USER2 REALHOST
     #+end_src
**** Setup a socks proxy
     Setup a socks tunnel to HOST at port 9090. The option =-N= is to
     disable the prompt to make it easier to keep track of which
     terminal runs the tunnel.
     #+begin_src sh
     ssh -ND9090 HOST
     #+end_src
*** houdini
**** Expression for string parameters
     Create a keyframe (Alt+LMB or "Channels and keyframes" -> "set Keyframe")
     Then edit the expression.
*** KDE
**** no borders
     When disabled use ALT+F3 to bring the menu back.
*** CMake
    Don't remove the rpath when installing.
    #+begin_src sh :tangle no
      CMAKE_INSTALL_RPATH_USE_LINK_PATH=TRUE
    #+end_src

    Specify c++ compiler.
    #+begin_src sh :tangle no
      CMAKE_CXX_COMPILER=$(GCC_PACKAGE_ROOT)/bin/g++
    #+end_src
*** Yum
    Find what package a file belongs to:
    #+begin_src sh :tangle no
      yum whatprovides /path/to/file
    #+end_src
*** rpm
    Find what package a file belongs to:
    #+begin_src sh :tangle no
      rpm -qf /path/to/file
    #+end_src
*** GDB
    Bypass the pretty printer and show the raw data.
    #+begin_src :tangle no
    p/r VARIABLE
    #+end_src
*** PDB
    To use pdb with emacs, simply =M-x= =pbd=. If =pdb= does not exist
    as an executable on the machine, use =python -m pdb= instead in
    the prompt.

    To change working directory (default it uses the path of the script). Use
    #+begin_src python :tangle no
    import os; os.chdir('PATH')
    #+end_src
    in the =pdb= prompt.
*** Ledger
**** Check what you spend on X
    #+begin_src sh
      ledger -f data.dat reg payee "X" -s
    #+end_src
**** Scripts
     #+begin_src sh
       env LEDGER_FILE=data.dat scripts/cashflow.sh
     #+end_src
*** Github
**** Preview site of a git hosted website
     Prepend to the original url.
     #+begin_src org :tangle no
       http://htmlpreview.github.io/?
     #+end_src
     For example to see an older page of the embree docs.
     #+begin_src org :tangle no
       https://htmlpreview.github.io/?https://raw.githubusercontent.com/embree/embree.github.com/v2.15.0/index.html
     #+end_src
     source: [[https://stackoverflow.com/questions/8446218/how-to-see-an-html-page-on-github-as-a-normal-rendered-html-page-to-see-preview][stackoverflow]]
*** gcc
**** Generate a list of all defined macros
     cpp -dM /dev/null
***** Check what __cplusplus is set to when setting a language standard in c++
      Need to tell cpp that we only are interested in c++ then we can
      just pass the flags we want.

      For example check what __cplusplus is set to when using c++14.
      #+begin_src sh
        cpp -dM -x c++ -std=c++14 /dev/null | grep __cplusplus
      #+end_src
**** Trace undefined symbol
     use ld's --trace-symbol=<symbol> when linking to get a list of
     what file(s) are using that symbol. Using it with gcc it would be
     #+begin_src sh :tangle no
       gcc <options> -Wl,--trace-symbols=<symbol>
     #+end_src
**** Don't allow undefined symbols in shared libraries
     When enabled it will error out if it finds any undefined symbols
     when linking a shared library.
     #+begin_src sh :tangle no
       gcc <options> -Wl,--no-undefined
     #+end_src
     or
     #+begin_src sh :tangle no
       gcc <options> -Wl,z defs
     #+end_src

**** Record flags in object file
     Will record the flags used to build the object into the object
     file.
     #+begin_src sh :tangle no
       gcc -frecord-gcc-switches
     #+end_src

     There is also =-grecord-gcc-switches= that works similarly.

     To extract the flags from the object file:
     #+begin_src sh :tangle no
       objdump -s -j .GCC.command.line <object file> | sed -En 's/ [[:xdigit:]]{4}( [[:xdigit:] ]{8}){4}  ([^ ]*)/\2/p' | tr -d "\n" | sed -E -e 's/\.-/ -/g' -e 's/[. ]+$/\n/'
     #+end_src
**** Output absolute path to a library

     #+begin_src sh :tangle no
       gcc -print-file-name=<library>
     #+end_src

     This will print out the absolute path to the =<library>=. The
     library needs to have it's prefix =lib= and extenssion for it to
     print it out. For example

     #+begin_src sh :tangle no
       gcc -print-file-name="stdc++"
     #+end_src

     Will just print out =stdc++=. Where as

     #+begin_src sh :tangle no
       gcc -print-file-name="libstdc++.so"
     #+end_src

     Will print out the absolute path to the =libstdc++= it will use
     to link against.
**** Print only the commands it will run

     #+begin_src sh :tangle no
       gcc -###
     #+end_src

     It's similar to =-v= except it will quote the arguments and not
     run the commands
